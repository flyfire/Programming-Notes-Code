# 面向对象

---
## 类与对象

- 类: 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例
- 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用
- 类方法：类中定义的函数。至少由一个默认参数为cls，代表该类
- 继承：即一个派生类继承基类的字段和方法
- 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖，也称为方法的重写
- 实例化：创建一个类的实例
- 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法
- 实例变量：定义在方法中的变量，只作用于当前实例的类。
- 对象属性：为对象添加的属性，通过对象访问
- 对象方法：类中定义的函数。至少由一个默认参数为self，代表调用该方法的实例对象
- 静态方法：静态方法定义在类中，没有默认参数，通过类名调用
- 对象的三个特征：`id、value、type`

理解：

- Python编程有很多默认的约定，我们需要准守好这些约定，比如私有变量以`__`开始
- 严格意义上来讲，Python并没有所谓的私有变量，也不会阻止你去访问对象的任何变量，对私有变量的保护只是一个重命名
- Python很多地方没有严格限制我们的程序编写，更多的时候需要开发者去遵守那些约定俗成的规定

---
## 继承

- Python支持继承，并且有限的支持多继承
- 多继承方法查找：若是多个父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。
- 父类方法的调用方式

---
## 私有化

- `xx`： 公有变量
- `_x`：单前置下划线,私有化属性或方法，`from somemodule import *`禁止导入,类对象和子类可以访问，`import somemodule`依然可以访问
- `__xx`：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)
- `__xx__`：双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__`, 不要自己发明这样的名字
- `xx_`：单后置下划线,用于避免与Python关键词的冲突

通过name mangling(名字重整(目的就是以防子类意外重写基类的方法或者属性)如：`_Class__object`)机制可以访问private。

总结：
- 父类中属性名为`__x`名字的，子类不继承，子类不能访问
- 如果在子类中向`__x`名字赋值，那么会在子类中定义的一个与父类相同名字的属性
- `_z`名的变量、函数、类在使用`from xxx import *`时都不会被导入


---
## 属性property

- 私有属性添加getter和setter方法：`xxx = property(getXxx, setXxx)`
- 使用property取代getter和setter方法：`@property`

---
## 类的专有方法

- `__new__` ： 创建对象的函数
- `__init__` ： 构造函数，在生成对象时调用
- `__del__` ： 析构函数，释放对象时使用
- `__str__`：类似Java的toString方法
- `__repr__` ： 转换
- `__setitem__` ： 按照索引赋值
- `__getitem__`： 按照索引获取值
- `__len__`： 获得长度
- `__bool__`：转换为bool
- `__cmp__`： 比较运算
- `__call__`： 函数调用
- `__add__`： 加运算
- `__sub__`： 减运算
- `__mul__`： 乘运算
- `__div__`： 除运算
- `__mod__`： 求余运算
- `__pow__`： 乘方

---
## 枚举

```python
# 导入枚举模块
from enum import Enum
#集成Enum即为枚举类型
class VIP(Enum):
    YELLOW = 1
    YELLOW_ALIAS = 1 # 别名
    GREEN = 2
    BLACK = 3
    RED = 4
```

- 枚举类是不可变的
- 如果枚举中两个具体的枚举取值相等，那么第二个枚举相当于第二个枚举的别名
- IntEnum、unique装饰器
