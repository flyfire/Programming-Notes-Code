# 函数式编程

Python一切皆对象的性质很好的支持了函数式编程

---
## 闭包、匿名函数

闭包(Closure)：又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。

Lambda表达式：`lambda parameter_list: expression`


---
## functools 模块

 - map
 - reduce
 - filter

---
## 装饰器

本质上，decorator就是一个返回函数的高阶函数。`@函数名` 是python的一种语法糖。 让装饰器的使用非常简便。函数可以同时应用多个装饰器

### 装饰器的执行

```python
def w1(func):
    def inner():
        # 验证1
        # 验证2
        # 验证3
        func()
    return inner

@w1
def f1():
    print('f1')
```
上面代码的执行步骤：

1. `def w1(func):` ==>将w1函数加载到内存
2. `@w1`

从表面上看解释器仅仅会解释这两句代码，因为函数在没有被调用之前其内部代码不会被执行。但是 `@w1` 这一句代码里却隐含很多细节， `@函数名` 是python的一种语法糖。

`@w1`内部会执行以下操作：

1. 执行w1函数，并将 @w1 下面的函数作为w1函数的参数，即：`@w1` 等价于 `w1(f1) `
2. w1的返回值，将执行完的w1函数返回值 赋值 给`@w1`下面的函数的函数名f1 即将w1的返回值再重新赋值给 f1，所以`@w1`有一个包装再替换的过程，即包装原有函数，在将原有函数替换为包装后的函数

### 装饰器注意

- 无参数的函数
- 被装饰的函数有参数
- 被装饰的函数有不定长参数，使用`*args, **kwargs`
- 一般情况下为了让装饰器更通用，需要有return
- 使用`@functools.wraps(func)`修复函数替换后获取`__name__`不对的问题
- 函数同时应用多个装饰器，装饰器的执行顺序

### 类装饰器

装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，
但也有例外。只要某个对象重写了 `__call__()` 方法，那么这个对象就是callable的。所以callable的类也可以作为装饰器使用，示例如下：
 

### 应用

- 打印日志
- 方法拦截
- 函数执行时间统计
- 执行函数前预备处理
- 执行函数后清理功能
- 权限校验等场景
- 缓存
- aop