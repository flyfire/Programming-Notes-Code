# Kotlin Coroutine 核心组件说明

---
## 1 CoroutineContext

上下文很常见，比如Android里的Context，可以认为上下文是一个编程环境。具体一点就是“与现在这个工作相关的周围环境”
这个Context里有一些和当前编程相关的方法和变量。参考[如何理解上下文](https://www.zhihu.com/question/26387327)

CoroutineContext即协程的上下文，这个上下文可以是多个的组合，CoroutineContext的定义如下：

```kotlin
//CoroutineContext是一个接口
public interface CoroutineContext {
    //[]操作符重载，通过key获取对应的Element，Element继承自CoroutineContext，可以理解为通过key获取对应的上下文
    public operator fun <E : Element> get(key: Key<E>): E?
    
    public fun <R> fold(initial: R, operation: (R, Element) -> R): R
    
    //+操作符重载，支持上下文之间的组合：协程的上下文可以是多个的组合，组合的上下文可以通过 key 来获取。
    public operator fun plus(context: CoroutineContext): CoroutineContext
    
    //减去key，移除一个上下文
    public fun minusKey(key: Key<*>): CoroutineContext
}

//Element的定义如下，一个上下文对应一个Element概念
    public interface Element : CoroutineContext {
        //一个用于获取上下文的key
        public val key: Key<*>
    }
    
//Key的定义如下
public interface Key<E : Element>
```

CoroutineContext的子类实现

- `AbstractCoroutineContextElement`：CoroutineContext的基础实现，其构成方法需要一个Key参数
- `EmptyCoroutineContext`：，EmptyCoroutineContext 是一个空实现，没有任何功能，
如果我们在使用协程时不需要上下文，那么我们就用这个对象作为一个占位即可。

---
## 2 Continuation

挂起的协程可以作为保持其挂起状态与局部变量的对象来存储和传递。这种对象的类型是 Continuation

Continuation有继续、持续的意思。Continuation中定义了继续执行协程的方法

Continuation 有两个方法：

- 一个是 `resume`，如果我们的程序没有任何异常，那么直接调用这个方法并传入需要返回的值。
- 一个是 `resumeWithException`，如果我们的程序出了异常，那我们可以通过调用这个方法把异常传递出去。

```kotlin
public interface Continuation<in T> {
    //Continuation持有的上下文
    public val context: CoroutineContext
    //如果我们的程序没有任何异常，那么直接调用这个方法并传入需要返回的值
    public fun resume(value: T)
    //如果我们的程序出了异常，那我们可以通过调用这个方法把异常传递出去
    public fun resumeWithException(exception: Throwable)
}
```

协程的基本操作包括创建、启动、暂停和继续，继续的操作在 Continuation 当中，其他的都在包级函数当中

### CoroutinesLibrary.kt:

启动一个协程，这是一个**suspend函数**添加的扩展方法：
```kotlin
public fun <R, T> (suspend R.() -> T).startCoroutine(receiver: R, completion: Continuation<T>)
public fun <T> (suspend  () -> T).startCoroutine(completion: Continuation<T>) {}
public inline suspend fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T
```

创建一个协程，这是一个**suspend函数**添加的扩展方法
```kotlin
public fun <R, T> (suspend R.() -> T).createCoroutine(receiver: R,completion: Continuation<T>): Continuation<Unit> = SafeContinuation(createCoroutineUnchecked(receiver, completion), COROUTINE_SUSPENDED)
public fun <T> (suspend () -> T).createCoroutine( completion: Continuation<T>): Continuation<Unit> 
```

暂停一个协程，这是一个**suspend函数**添加的扩展方法
```kotlin
public inline suspend fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T
```

### Delay.kt:

在给定的时间内延迟协程，仅用于协程
```kotlin
suspend fun delay(time: Long, unit: TimeUnit = TimeUnit.MILLISECONDS){}
```

### Yield.kt:

转让当前协程转调器的线程(或线程池)的执行权到其他协程
```kotlin
suspend fun yield(): Unit
```

suspend关键字用于修饰暂停函数，只有在协程中可以调用suspend函数

---
## 3 ContinuationInterceptor  拦截器

ContinuationInterceptor继承了Element，所以它本身是一个协程上下文，然后其添加了拦截功能，可以拦截协程的调度，

```kotlin
public interface ContinuationInterceptor : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<ContinuationInterceptor>
    //拦截调度，返回新的Continuation
    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>
}
```

## 4 CoroutineDispatcher

CoroutineDispatcher是协程的调度器，由它来调度和处理任务

```kotlin
public abstract class CoroutineDispatcher :
        AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
            public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
            //分派runnable(块)到给定的上下文的另一个线程的执行。
            public abstract fun dispatch(context: CoroutineContext, block: Runnable)
            public override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =
                        DispatchedContinuation(this, continuation)
                        
        }
        public operator fun plus(other: CoroutineDispatcher) = other
```

可见CoroutineDispatcher继承了ContinuationInterceptor，显然需要处理协程的调度，当然需要拦截的能力
——拦截一个协程在原来线程上的运行，然后调度到另一个线程上执行


---
##  5 CoroutineScope

CoroutineScope是通用的协程构建器receiver，其封装了协程的内部状态：`isActive和coroutineContext`属性，
isActive表示协程是否是活跃的(没有完成也没有被取消)，coroutineContext表示当前这个协程的上下文。

所谓通用的协程构建器receiver，即协程运行block都以CoroutineScope为运行环境，**这是Kotlin中带接收者的函数字面值的应用**
，以下面函数为例：
```kotlin
public fun launch( context: CoroutineContext,start: CoroutineStart = CoroutineStart.DEFAULT,block: suspend CoroutineScope.() -> Unit): Job {
     //......
    return coroutine
}
```
上面launch的block参数指定了receiver为CoroutineScope，所以在在block的运行就行在CoroutineScope内部一样，可以访问CoroutineScope的成员属性。


---
## 6 启动协程的函数

在协程构造器文件中(Builders.kt)定义了一系列用于启动协程的函数。

```kotlin
//作为一个适配器，用于启动顶级主协程，运行一个新的协程并且阻塞当前线程直到协程执行完毕， 当前线程可中断。
public fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T {
    //......
    return coroutine.joinBlocking()
}

//启动一个新的协程并返回一个代表协程引用的Job对象，当前线程不会被阻塞
public fun launch( context: CoroutineContext,start: CoroutineStart = CoroutineStart.DEFAULT,block: suspend CoroutineScope.() -> Unit): Job {
     //......
    return coroutine
}

//通过协程启动函数launch创建并返回，Job可以被取消，Job的join函数会让当前协程会等到代表Job的协程运行完毕后再执行
public interface Job : CoroutineContext.Element {}

//Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result.
public suspend fun <T> run(  context: CoroutineContext,  start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend () -> T): T
```

带有返回值的协程——Deferred.kt:

```kotlin
public fun <T> async(context: CoroutineContext,start: CoroutineStart = CoroutineStart.DEFAULT,block: suspend CoroutineScope.() -> T): Deferred<T> {
    //......
    return coroutine
}

//由协程启动函数async创建并返回，其多一个await函数，当协程执行完毕，await方法会被调用并返回值(但并不是回调方式)
public interface Deferred<out T> : Job {
   public suspend fun await(): T
}
```

---
## 7 CommonPool

CommonPool是一个协程调度器，适用于计算密集型任务。当[java.util.concurrent.ForkJoinPool] 可用时，内部会使用它允许异步任务。

---
## 8 Scheduled & ThreadPoolDispatcher

Scheduled中定义了一些协程调度相关的工具方法
```kotlin
//给协程设置超时
public suspend fun <T> withTimeout(time: Long, unit: TimeUnit = TimeUnit.MILLISECONDS, block: suspend () -> T): T {}
public suspend fun <T> withTimeoutOrNull(time: Long, unit: TimeUnit = TimeUnit.MILLISECONDS, block: suspend () -> T): T? {}
```

ThreadPoolDispatcher中定义了一些创建协程调度器的方法

```kotlin
fun newFixedThreadPoolContext(nThreads: Int, name: String, parent: Job? = null): CoroutineContext
fun newSingleThreadContext(name: String, parent: Job? = null): CoroutineContext
```

---
## 9 CoroutineStart

CoroutineStart是一个枚举类型，它是一个选项值，表示如何启动协程，
在launch和async都需要CoroutineStart类型参数，但这个参数由默认值，
CoroutineStart.DEFAULT。CoroutineStart的值和说明如下：

- `DEFAULT` 表示根据其上下文立即安排协程执行
- `LAZY` 表示延迟启动协程
- `ATOMIC`
- `UNDISPATCHED`


---
## 总结

虽然有这么多概念，但是简单的使用协程只需要掌握以下函数：

```
- fun launch(): Job //启动一个新的协程并返回一个代表协程引用的Job对象
- fun async(): Deferred//用于启动一个洗的协程，返回的Deferred对象表示带有返回值的协程
```