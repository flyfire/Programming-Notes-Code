# 协程

---
## 1 协程的概念

### 子程序

子程序即函数，函数调用是通过调用栈来实现的，而栈只有一个入口和一个出口，所以可以认为函数的调用是线性的，
调用顺序非常明确

### 协程

- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，
可以看出协程中函数可以有多个入口。
- 协程存在的意义：**让异步代码看上去像同步代码，直接自然易懂** 。至于它如何做到这一点，可能各家的语言实现各有不同。

协程与线程的区别是：

- 一个协程可以有多个入口，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。
- 线程是由CPU的调度，是一种抢占式调度，而协程的调度是非抢占式的。
- 协程一般是有编译器实现的，而线程是由系统CPU调度的，线程是更加底层的东西，而协程是更高一层的封装。

---
## 2 kotlin协程

kotlin协程的异步需要依赖比它更底层的 API 支持，那么在Kotlin当中，这个所谓的底层API就非线程莫属了。

### 协程概念和作用

一些耗时操作(网络IO、文件IO、CPU/GPU密集型任务)会阻塞线程直到操作完成，
Kotlin的协程提供一种避免阻塞且更廉价可控的操作: 协程挂起(coroutine suspension)，
协程将复杂异步操作放入底层库中，**程序逻辑可顺序表达**，以此简化异步编程，
该底层库将用户代码包装为**回调/订阅**事件在**不同线程(甚至不同机器)调度执行**。

### 线程阻塞和协程挂起的区别

协程是通过编译技术实现(不需要虚拟机VM/操作系统OS的支持)，通过插入相关代码来生效！ 与之相反，
线程/进程是需要虚拟机VM/操作系统OS的支持，通过调度CPU执行生效!

- **线程阻塞的代价昂贵**， 尤其在高负载时的可用线程很少，阻塞线程会导致一些重要任务缺少可用线程而被延迟!

- 协程挂起几乎无代价，无需上下文切换或涉及OS， 最重要的是，协程挂起可由用户控制：
可决定挂起时发生什么，并根据需求优化/记录日志/拦截，另一个不同之处是：
**协程不能在随机指令中挂起，只能在挂起点挂起(调用标记函数)**
