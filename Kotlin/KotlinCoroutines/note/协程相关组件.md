Coroutine即通过以下方式(比如编译技术，对底层库的封装)是让异步编程变得更加简单，看起来就像是在同步编程一样。
于线程的区别是，一个协程可以有多个入口，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。
具体参考[维基百科](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B)


Kotlin Coroutine 中的组件说明

## 1 CoroutineContext

上下文很常见，比如Android里的Context，可以认为上下文是一个编程环境。具体一点就是“与现在这个工作相关的周围环境”
这个Context里有一些和当前编程相关的方法和变量。参考[如何理解上下文](https://www.zhihu.com/question/26387327)

```kotlin
//CoroutineContext的定义如下
public interface CoroutineContext {
    //通过key获取对应的Element，Element继承自CoroutineContext，可以理解为通过key获取对应的上下文
    public operator fun <E : Element> get(key: Key<E>): E?
    public fun <R> fold(initial: R, operation: (R, Element) -> R): R
    //操作符重载，支持上下文之间的组合：协程的上下文可以是多个的组合，组合的上下文可以通过 key 来获取。
    public operator fun plus(context: CoroutineContext): CoroutineContext
    //减去key，移除一个上下文
    public fun minusKey(key: Key<*>): CoroutineContext
}

//Element的定义如下，一般上下文对应一个Element概念
    public interface Element : CoroutineContext {
        //一个用于获取上下文的key
        public val key: Key<*>
    }
    
//Key的定义如下
public interface Key<E : Element>
```

CoroutineContext的继承关系

- AbstractCoroutineContextElement：CoroutineContext的基础实现，其构成方法需要一个Key参数
- EmptyCoroutineContext：，EmptyCoroutineContext 是一个空实现，没有任何功能，
如果我们在使用协程时不需要上下文，那么我们就用这个对象作为一个占位即可。


## 2 Continuation

Continuation有继续、持续的意思。协程提供了一种暂停的能力，可继续执行才是最终的目的。
Continuation中定义了继续执行协程的方法

Continuation 有两个方法：

- 一个是 resume，如果我们的程序没有任何异常，那么直接调用这个方法并传入需要返回的值；
- 一个是 resumeWithException，如果我们的程序出了异常，那我们可以通过调用这个方法把异常传递出去。

```kotlin
public interface Continuation<in T> {
    //Continuation持有的上下文
    public val context: CoroutineContext
    //如果我们的程序没有任何异常，那么直接调用这个方法并传入需要返回的值
    public fun resume(value: T)
    //如果我们的程序出了异常，那我们可以通过调用这个方法把异常传递出去
    public fun resumeWithException(exception: Throwable)
}
```

协程的基本操作包括创建、启动、暂停和继续，继续的操作在 Continuation 当中，其他的都在包级函数当中

CoroutinesLibrary.kt:
```kotlin
//启动一个协程，这是一个suspend函数添加的扩展方法
public fun <R, T> (suspend R.() -> T).startCoroutine(receiver: R, completion: Continuation<T>)
public fun <T> (suspend  () -> T).startCoroutine(completion: Continuation<T>) {}
//创建一个协程，这是一个suspend函数添加的扩展方法
public fun <R, T> (suspend R.() -> T).createCoroutine(receiver: R,completion: Continuation<T>): Continuation<Unit> = SafeContinuation(createCoroutineUnchecked(receiver, completion), COROUTINE_SUSPENDED)
public fun <T> (suspend () -> T).createCoroutine( completion: Continuation<T>): Continuation<Unit> 
//暂停一个协程，这是一个suspend函数添加的扩展方法
public inline suspend fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T
```
Delay.kt:
```kotlin
//在给定的时间内延迟协程，仅用于协程
suspend fun delay(time: Long, unit: TimeUnit = TimeUnit.MILLISECONDS){}
```
Yield.kt:
```kotlin
//让当前协程转调器的线程(或线程池)的执行权到其他协程
suspend fun yield(): Unit
```
suspend关键字用于修饰暂停函数，只有在协程中可以调用suspend函数

## 3 ContinuationInterceptor  拦截器

ContinuationInterceptor继承了Element，所以它本身是一个协程上下文，然后其添加了拦截功能，可以拦截协程的调度，

```kotlin
public interface ContinuationInterceptor : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<ContinuationInterceptor>
    //拦截调度，返回新的Continuation
    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>
}
```

## 4 CoroutineDispatcher

CoroutineDispatcher是协程的调度器，由它来调度和处理任务

```kotlin
public abstract class CoroutineDispatcher :
        AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
            public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
            //分派runnable(块)到给定的上下文的另一个线程的执行。
            public abstract fun dispatch(context: CoroutineContext, block: Runnable)
            public override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =
                        DispatchedContinuation(this, continuation)
                        
        }
        public operator fun plus(other: CoroutineDispatcher) = other
```

可见CoroutineDispatcher继承了ContinuationInterceptor，显然需要处理协程的调度，当然需要拦截的能力。
拦截的能力：拦截一个协程在原来线程上的运行，然后调度到另一个线程上执行

##  5 CoroutineScope

CoroutineScope是通用的协程构建器receiver，其封装了协程的内部状态：`isActive和context`

所谓通用的协程构建器receiver，即协程运行block都以CoroutineScope为运行环境，看下面启动协程的函数就明白了


## 6 启动协程的函数

在协程构造器文件中(Builders.kt)定义了一系列用于启动协程的函数。

```kotlin
//作为一个适配器，用于启动顶级主协程，运行一个新的协程并且阻塞当前线程直到协程执行完毕， 当前线程可中断。
public fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T {
    //......
    return coroutine.joinBlocking()
}

//启动一个新的协程并返回一个代表协程引用的Job对象，当前线程不会被阻塞
public fun launch( context: CoroutineContext,start: CoroutineStart = CoroutineStart.DEFAULT,block: suspend CoroutineScope.() -> Unit): Job {
     //......
    return coroutine
}

//通过协程启动函数launch创建并返回，Job可以被取消，Job的join函数会让当前协程会等到代表Job的协程运行完毕后再执行
public interface Job : CoroutineContext.Element {}

//Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result.
public suspend fun <T> run(  context: CoroutineContext,  start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend () -> T): T
```

带有返回值的协程——Deferred.kt:
```kotlin
public fun <T> async(context: CoroutineContext,start: CoroutineStart = CoroutineStart.DEFAULT,block: suspend CoroutineScope.() -> T): Deferred<T> {
    //......
    return coroutine
}

//有协程启动函数async创建并返回，其多一个await函数，当协程执行完毕，await方法会被调用并返回值(但并不是回调方式)
public interface Deferred<out T> : Job {
   public suspend fun await(): T
}
```

## 7 CommonPool

CommonPool是一个协程调度器，适用于计算密集型任务。内部使用了[java.util.concurrent.ForkJoinPool] 

## Scheduled & ThreadPoolDispatcher

Scheduled中定义了一些协程调度相关的工具方法
```kotlin
//给协程设置超时
public suspend fun <T> withTimeout(time: Long, unit: TimeUnit = TimeUnit.MILLISECONDS, block: suspend () -> T): T {}
public suspend fun <T> withTimeoutOrNull(time: Long, unit: TimeUnit = TimeUnit.MILLISECONDS, block: suspend () -> T): T? {}
```

ThreadPoolDispatcher中定义了一些创建协程调度器的方法
```kotlin
fun newFixedThreadPoolContext(nThreads: Int, name: String, parent: Job? = null): CoroutineContext
fun newSingleThreadContext(name: String, parent: Job? = null): CoroutineContext
```
