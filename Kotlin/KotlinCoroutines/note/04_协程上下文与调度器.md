#  协程上下文与调度器

协程总是在由CoroutineContext表示的上下文中执行。
协程的上下文是一组不同的elements。

## 1 Dispatchers(调度器)

CoroutineContext 包含一个Dispatchers，它确定对应协程用于执行的线程或线程池。
Dispatchers可以将协程执行限制在一个特定的线程上，将其调度到线程池，或者让其无限制地运行。

Kotlinx协程中提供了默认的协程调度器，还允许我们实现自己的协程调度器：

- Unconfined：表示不约束协程调度线程，它初始化时使用当前线程作为调度器，然后如果它被挂起了，它将使用恢复它的线程中执行，
所以每次它被挂起恢复后，调度它的线程就会发生变化
- CommonPool：如果ForkJoinPool可用，CommonPool将使用ForkJoinPool线程池调度协程
- ThreadPoolDispatcher：ThreadPoolDispatcher中提供了一些函数用于创建可用的协程调度器，比如newSingleThreadContext函数，需要
注意但是，如果不在需要创建的协程调度器，应该及时的释放它们。

## 2 Unconfined

Unconfined调度程序适用于不消耗CPU时间，也不更新任何局限于特定线程的共享数据（如UI）。


## 3 coroutineContext属性

通过CoroutineScope接口在任何协程块中可以访问coroutineContext属性，coroutineContext是对这个特定协程的上下文的引用。


## 4 协程调试

启动VM时，指定参数：`-Dkotlinx.coroutines.debug`

## 5 Job

1.  Job是其context的一部分。协程可以使用`coroutineContext[Job]`表达式获取job
2. 当一个协程的context用于去启动其他协程，新的协程的Job将会成为其父协程Job的子Job，当
父协程被取消，所有的字写成也会被递归的取消。

## 6 协程上下文组合

1. 使用`+`运算符可以组合多个上下文，右侧的上下文替换左侧上下文的相关条目，包括协程调度器。
2. 组合CoroutineName可以给协程命名

## 7 管理多个协程
```kotlin
    val job = Job() // create a job object to manage our lifecycle

    // now launch ten core.base for a demo, each working for a different time
    val coroutines = List(10) { i ->
        // they are all children of our job object
        launch(coroutineContext + job) {
            // we use the context of main runBlocking thread, but with our own job object
            delay(i * 200L) // variable delay 0ms, 200ms, 400ms, ... etc
            println("Coroutine $i is done")
        }
    }

    println("Launched ${coroutines.size} core.base")
    delay(500L) // delay for half a second
    println("Cancelling job!")
    job.cancel() // cancel our job.. !!!
```

