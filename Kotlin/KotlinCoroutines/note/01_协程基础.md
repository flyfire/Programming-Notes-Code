# 携程基础

## 1 launch

通过Builders中的launch函数，传入一个suspending函数，可以启动一个协程。

**launch作用**：启动一个新的协程并返回一个代表协程引用的Job对象，当前线程不会被阻塞，调用launch时可以指定协程上下文。

**CommonPool作用**：它是一个协程上下文，同时也是一个协程调度器，用于协程调度程序的计算密集型任务。
如果在launch中传入CommonPool，此时协程将会在CommonPoll提供的线程池中运行。

**delay作用**：在给定的时间内延迟协程，此时该协程将让出执行权(delay是非阻塞的)，仅用于协程中使用。
当一个suspending函数在等待时，如果取消这个它(或者它已经完成了)将会抛出CancellationException异常


## 2 runBlocking

如果我们希望直接在主线程上面创建协程，那么可以使用runBlocking，runBlocking作用:

1. 作为一个适配器，用于启动顶级主协程
2. 运行一个新的协程并且阻塞当前线程直到协程执行完毕， 当前线程可中断。
3. runBlocking适用于主函数或者测试中，
4. 如果这个阻塞的线程被中断, 内部的协程将会被取消，runBlocking 调用抛出InterruptedException.
5. 使用runBlocking启动协程，会阻塞当前的协程，所以不要在协程中再使用runBlocking启动协程，因为这样没有什么意义

## 3 协程等待机制——join

launch返回一个**代表协程调度的后台任务**Job，Job的join方法可以让协程等待另一个协程。

join作用：当调用jon的jon方法时，此时当前协程会等到之前启动的协程运行完毕(Suspends coroutine until this job is complete)

## 4 协程是轻量级的


能创建线程的数量公式：`Number of Threads = (MaxProcessMemory - JVMMemory - ReservedOsMemory) /(ThreadStackSize)`

- MaxProcessMemory 指的是一个进程的最大内存
- JVMMemory JVM内存
- ReservedOsMemory 保留的操作系统内存
- ThreadStackSize 线程栈的大小

一般我们如果创建100_000个线程，铁定会抛出OOM异常，而协程却不会。

协程是轻量级的，它拥有自己的运行状态，但它对资源的消耗却非常的小。
协程不是线程，携程由程序自己管理，所以即使创建1000个携程也不会什么很大的消耗。

```kotlin
fun main(args: Array<String>) = runBlocking {
    //这里创建了100_000协程
    val jobs = List(100_000) {
        launch(CommonPool) {
            delay(2000L)//每一个协程都停一秒，但是相互之间并不阻塞
            print(".")
        }
    }
    println(jobs.size)
    jobs.forEach { it.join() }
    println(" end ....")
}
```

## 5 协程就像守护线程一样

当主线程退出时，协程也会退出。

```
fun main(args: Array<String>) = runBlocking {
    //withTimeout作用：Runs a given suspending block of code inside a coroutine with a specified timeout and throws
    // CancellationException if timeout was exceeded.
    //给定时间被协程没有执行完毕，将会抛出异常
    try {
        withTimeout(1300L) {
            repeat(1000) { i ->
                println("I'm sleeping $i ...")
                delay(500L)
            }
        }
        println("ending=---")
    } catch (e: CancellationException) {
        e.printStackTrace(System.err)
    }
}
```