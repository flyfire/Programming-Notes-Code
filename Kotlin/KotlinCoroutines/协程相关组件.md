# 1 概念

## CoroutineContext

协程的上下文，这个上下文可以是多个的组合，组合的上下文可以通过 key 来获取。

EmptyCoroutineContext 是一个空实现，没有任何功能，如果我们在使用协程时不需要上下文，那么我们就用这个对象作为一个占位即可。

```kotlin
//CoroutineContext的定义如下
public interface CoroutineContext {
    //通过key获取对应的Element，Element继承自CoroutineContext，可以理解为通过key获取对应的上下文
    public operator fun <E : Element> get(key: Key<E>): E?
    public fun <R> fold(initial: R, operation: (R, Element) -> R): R
    //操作符重载，支持上下文之间的组合
    public operator fun plus(context: CoroutineContext): CoroutineContext
    //减去key，移除一个上下文
    public fun minusKey(key: Key<*>): CoroutineContext
}

//Element的定义如下，一般上下文对应一个Element概念
    public interface Element : CoroutineContext {
        //一个用于获取上下文的key
        public val key: Key<*>
    }
    
//Key的定义如下
public interface Key<E : Element>
```
CoroutineContext的继承关系

- AbstractCoroutineContextElement：CoroutineContext的基础实现，其构成方法需要一个Key参数
- EmptyCoroutineContext：CoroutineContext的空实现

## Continuation

Continuation有继续、持续的意思。协程提供了一种暂停的能力，可继续执行才是最终的目的。Continuation中定义了继续执行协程的方法

Continuation 有两个方法：

- 一个是 resume，如果我们的程序没有任何异常，那么直接调用这个方法并传入需要返回的值；
- 一个是 resumeWithException，如果我们的程序出了异常，那我们可以通过调用这个方法把异常传递出去。

```kotlin
public interface Continuation<in T> {
    //Continuation持有的上下文
    public val context: CoroutineContext
    //如果我们的程序没有任何异常，那么直接调用这个方法并传入需要返回的值
    public fun resume(value: T)
    //如果我们的程序出了异常，那我们可以通过调用这个方法把异常传递出去
    public fun resumeWithException(exception: Throwable)
}
```

协程的基本操作包括创建、启动、暂停和继续，而继续的操作在 Continuation 当中，其他的都在包级函数当中

CoroutinesLibrary.kt:
```kotlin
//启动一个协程，这是一个suspend函数添加的扩展方法
public fun <R, T> (suspend R.() -> T).startCoroutine(receiver: R, completion: Continuation<T>)
public fun <T> (suspend  () -> T).startCoroutine(completion: Continuation<T>) {}
//创建一个协程，这是一个suspend函数添加的扩展方法
public fun <R, T> (suspend R.() -> T).createCoroutine(receiver: R,completion: Continuation<T>): Continuation<Unit> = SafeContinuation(createCoroutineUnchecked(receiver, completion), COROUTINE_SUSPENDED)
public fun <T> (suspend () -> T).createCoroutine( completion: Continuation<T>): Continuation<Unit> 
//暂停一个协程，这是一个suspend函数添加的扩展方法
public inline suspend fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T
```
suspend关键字用于修饰暂停函数，只有在协程中可以调用suspend函数

## ContinuationInterceptor  拦截器

ContinuationInterceptor继承了Element，所以它本身是一个协程上下文，然后其添加了拦截功能，可以拦截协程的调度，

```kotlin
public interface ContinuationInterceptor : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<ContinuationInterceptor>
    //拦截调度，返回新的Continuation
    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>
}
```

## CoroutineDispatcher

调度器，由它来调度和处理任务

```kotlin
public abstract class CoroutineDispatcher :
        AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
            public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
            //分派runnable(块)到给定的上下文的另一个线程的执行。
            public abstract fun dispatch(context: CoroutineContext, block: Runnable)
            public override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =
                        DispatchedContinuation(this, continuation)
                        
        }
        public operator fun plus(other: CoroutineDispatcher) = other
```

##  CoroutineScope

通用的协程构建器receiver，其封装了协程的内部状态：`isActive和context`

所谓通用的协程构建器receiver，即协程运行block都以CoroutineScope为运行环境，看下面函数就明白了


## 启动协程的函数

在协程构造器文件中(Builders.kt)定义了一系列用于启动协程的函数。

```kotlin
public fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T {
    //......
    return coroutine.joinBlocking()
}

public fun launch( context: CoroutineContext,start: CoroutineStart = CoroutineStart.DEFAULT,block: suspend CoroutineScope.() -> Unit): Job {
     //......
    return coroutine
}

public suspend fun <T> run(  context: CoroutineContext,  start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend () -> T): T
```

Deferred.kt:
```kotlin
public fun <T> async(context: CoroutineContext,start: CoroutineStart = CoroutineStart.DEFAULT,block: suspend CoroutineScope.() -> T): Deferred<T> {
    //......
    return coroutine
}

```

