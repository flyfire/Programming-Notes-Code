Kotlin基础类容

#  1 基础

## 1.1 语法

### 定义变量：DefineValue

   - 可变使用`var`
   - 常量使用`val`
    
### 条件表达式：ConditionExpression

   - 简单的函数声明省略大括号，直接使用表达式
    
### 流程控制：FlowControl

   - `if`：if表达式取代了三元运算符，kotlin中没有三元运算符
   - `for`
   - `while`
   - `when`：kotlin没有`switch`
   - 定义标签`loop1@`,标签返回`returnloop1@`

### 类型检查：TypeCheck

    - 类型检查用`is`，比如`obj is String`
    
### 比较：Compare
    
       ==比较：
           如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等
           对于引用类型： a==b等同于a?.equals(b) ?: (b === null)
       equals
           equals方法不能作用于基本数据类型的变量
           如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；
           诸如String、Date等类对equals方法进行了重写，比较的是所指向的对象的内容。
        === 和 !==
            a===b当且仅当a和b指向同一个对象时返回true

### 空检查

   - 当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。
    
## 1.2 数据类型

### 数字类型：NumberType

   - 支持的数字数据类型
   - 不同数字类型不能隐式转换，使用`toXXX`方法进行转换
   - 字面量支持二进制、十进制、十六进制，不支持八进制
   - 数字类型位操作：`shl、shr、ushr、and、or、xor、inv`
   - 当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性
    
### 字符类型

   - 它们不能直接当作数字，字符字面值用单引号括起来: '1'，特殊字符可以用反斜杠转义，
   - 编码其他字符要用 Unicode 转义序列语法：'\uFF00'。
   - 当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性
    
### 字符串类型：Strings

   - `"""`括起来的字符串会保留原来的换行格式
   - 字符串模板的使用方法：`$`
    
### 数组类型：Arrays

   - 数组类型使用Array表示
   - 数组在 Kotlin 中使用 Array 类来表示， 它定义了 get （按照运算符重载约定这会转变为 []）和 set 函数 和 size 属性，以及一些其他有用的成员函数
   - 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 `Array<String>` 赋值给 `Array<Any>`
   - Kotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、 ShortArray、IntArray 等等
   

    
使用集合：UseCollection

   - 有很多关于集合的方法可以直接使用，比如`setOf、listOf`等
   - 使用集合的`StreamAPI`可以很方便的操作集合数据

使用范围：Range
    
   - Range是一种数据结构，表示一个范围：比如1到5用`1..5`表示
   - 使用 `in` 运算符来检测某个数字是否在指定区间内
        

## 2 面向对象：oop

## 2.1  定义类：DefineClass


定义类

   - 类声明由类名、类头（指定其类型参数、主 构造函数等）和由大括号包围的类体构成。
   - 类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。
    -  主构造函数参数加上`var`或者`val`，则参数为此类上的属性，而次构造函数是不允许的
   - 类可以包含：**构造函数和初始化块、函数、属性、嵌套类和内部类、对象声明**

构造函数
   
   - 在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后
   - 主构造函数如果没有任何注解或者可见性修饰符，可以省略这个 `constructor` 关键字。
   - 主构造函数如果有注解或可见性修饰符，这个 `constructor` 关键字是必需的，并且这些修饰符在它前面
   - 主构造函数不能包含任何的代码。初始化的代码可以放 到以 `init` 关键字作为前缀的初始化块（initializer blocks）中
   - 主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用
   - 类也可以声明前缀有 `constructor` 的次构造函数
   - 如果类有一个主构造函数，每个次构造函数需要委托给主构造函数，可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数 用 this 关键字即可
   - 如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的 不带参数的主构造函数。构造函数的可见性是 `public`
   - 如果不希望类有一个公有构造函数，需要声明一个带有非默认可见性的空的主构造函数
   - 在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。
    
 创建类的实例
 
   - 创建类的实例：要创建一个类的实例，就像普通函数一样调用构造函数， Kotlin 并没有`new` 关键字。
   
 
 其他形式
   
   - 嵌套类：类可以嵌套在其他类中，内部类可以标记为 `inner` 以便能够访问外部类的成员。内部类会带有一个对外部类的对象的引用，此时必须使用外部类对象才能创建内部类对象
   - 匿名内部类：使用**对象表达式**创建匿名内部类实例，关键字为`object`
   - 如果对象是函数式Java接口（即具有单个抽象方法的 Java 接口）的实例， 可以使用带接口类型前缀的lambda表达式创建它` val listener = ActionListener { println("clicked") }`
   - 枚举类：枚举类的最基本的用法是实现类型安全的枚举
   - 与 Java 或 C# 不同，**在 Kotlin 中类没有静态方法**。在大多数情况下，它建议简单地使用包级函数。
    

## 2.2  继承：Inherit

   - 在 Kotlin 中所有类都有一个共同的超类 **Any**，这对于没有超类型声明的类是默认超类
   - Any 不是 `java.lang.Object`；尤其是，它除了 `equals()、hashCode()和toString()`外没有任何成员
   - 要声明一个显式的超类型，需要把类型放到类头的`:`之后
   - 如果基类有一个主构造函数，其基类型必须用基类型的主构造函数参数就地初始化。
   - 如果基类没有主构造函数，那么每个次构造函数必须 使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。
   - 类上的 `open` 标注与 Java 中 `final` 相反，它允许其他类 从这个类继承。默认情况下，在 Kotlin 中所有的类都是 `final`
   - Kotlin 需要显式标注可覆盖的成员（称之为开放）和覆盖后的成员
   - 子类的函数上必须加上 `override`标注。如果没写，编译器将会报错
   - 如果函数没有标注 `open`，则子类中不允许定义相同签名的函数， 不论加不加 `override`。
   - 在一个 `final` 类中（没有用 open 标注的类），开放成员是禁止的
   - 属性覆盖与方法覆盖类似：在超类中声明然后在派生类中重新声明的属性必须以 `override` 开头，并且它们必须具有兼容的类型。
   - 每个声明的属性可以由具有初始化器的属性或者具有 `getter` 方法的属性覆盖。
   - 可以用一个 `var` 属性覆盖一个 `val` 属性，但反之则不行。这是允许的，因为一个 `val` 属性本质上声明了一个`getter` 方法，而将其覆盖为 var 只是在子类中额外声明一个 setter 方法
   - 可以在主构造函数中使用 `override` 关键字作为属性声明的一部分。
   - 如果一个类从它的直接超类继承相同成员的多个实现，它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的` super`，如 `super<Base>`
    
    
## 2.3 抽象类：AbstractClass

   - 类和其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 
   - 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻
    
## 2.4  属性和字段：AttributesObjects

>注意区分属性、字段、方法，属性是带有setter和getter的，而kotlin的类中并没有字段，但是可以通过属性实现

定义属性

   - Kotlin的类可以有属性.属性可以用关键字var 声明为可变的，否则使用只读关键字val。
   - `Getters 和 Setters`：声明一个属性的完整语法包含：`初始器（initializer）、getter 和 setter`,其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器 （或者从其 getter 返回值，如下文所示）中推断出来，也可以省略
   - 一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 `val`  2、只读属性不允许 `setter`
   - 当访问一个属性时，其`getter`会被调用，而给一个属性赋值时，其`setter`会被调用
  
幕后字段

   - 幕后字段：Kotlin 中类不能有字段。然而，当使用自定义访问器时，有一个幕后字段（backing field）有时是必要的。为此 Kotlin 提供 一个自动幕后字段，它可通过使用 `field` 标识符访问。
   - 如果属性至少有一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段。
   - 幕后属性：如果你的需求不符合这套“隐式的幕后字段”方案，那么总可以使用 幕后属性（backing property）

编译期常量：已知值的属性可以使用 const 修饰符标记为 编译期常量。 这些属性需要满足以下要求：

   - 位于顶层或者是 object 的一个成员；
   - 用String或原生类型值初始化、
   - 没有自定义 getter

 延迟初始化属性：
 
   -  一般地，属性声明为非空类型必须在构造函数中初始化。可以用 `lateinit` 修饰符标记该属性来实现延迟初始化
   - `lateinit`修饰符只能用于在类体中（不是在主构造函数中）声明的 var 属性，并且仅当该属性没有自定义 `getter`或 `setter` 时。该属性必须是非空类型，并且不能是原生类型。
   - 在初始化前访问一个 `lateinit` 属性会抛出一个特定异常，该异常明确标识该属性 被访问及它没有初始化的事实。
    
## 2.5 接口：Interface

   - 定义接口：Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。
   - 接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。
   - 一个类或者对象可以实现一个或多个接口。
   - 可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。
    
## 2.6 可见性修饰符：VisibilityModifiers

    - 可见性修饰符：类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有可见性修饰符。 
    - 在 Kotlin 中有这四个可见性修饰符：`private、 protected、 internal 和 public` 如果没有显式指定修饰符的话，默认可见性是`public`
    -  一个模块是编译在一起的一套 Kotlin 文件
    
可见性规则：包名内
    - 函数、属性和类、对象和接口可以在顶层声明，即直接在包内
    - 如果声明为 `private`，只会在声明它的文件内可见
    - 如果声明为 `internal`，在相同模块内随处可见
    - `protected` 不适用于顶层声明
    
可见性规则：类和接口

    - `private`： 意味着只在这个类内部（包含其所有成员）可见
    - `protected`： 和 `private`一样，,但在子类中可见
    - `interna`：能见到类声明的本模块内的任何客户端都可见其internal 成员
    - `public`： 能见到类声明的任何客户端都可见其 public 成员。
    
可见性规则：构造函数
    - `class C private constructor(a: Int) { …… }`这里的构造函数是私有的。
    -  默认情况下，所有构造函数都是 `public`，这实际上 等于类可见的地方它就可见（即 一个 `internal` 类的构造函数只能 在相同模块内可见).
    
## 2.7  Kotlin扩展：KotlinExtend

    - Kotlin 同 C# 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式
    - 扩展一个类的新功能通过叫做扩展的特殊声明完成。Kotlin 支持扩展函数 和 扩展属性。
    - **扩展的作用域**：要使用所定义包之外的一个扩展，我们需要在调用方导入它
    - 扩展的两种写法，即是否记住扩展的方法
     
 扩展说明:
 
   - **扩展是静态的**：扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。
   - 扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的
   - 如果一个类定义有一个成员函数和一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字 并且都适用给定的参数，这种情况总是取成员函数。
   - **可空接收者**：注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，
   - **扩展属性**：和函数类似，Kotlin 支持扩展属性
   - 由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 `getters/setters` 定义
   - **扩展声明为成员**：在一个类内部可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 —— 其中的对象成员可以无需通过限定符访问。
   - 扩展声明所在的类的实例称为分发接收者
   - 扩展方法调用所在的接收者类型的实例称为 扩展接收者
   - 对于分发接收者和扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用 限定的this语法。
   
## 2.8 数据类：DataClass

   - 创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为` data`
   - 编译器自动从主构造函数中声明的所有属性导出这些成员：` equals()/hashCode()`, `toString()`, `componentN()`, `copy()`
   - 如果这些函数中的任何一个在类体中显式定义或继承自其基类型，则不会生成该函数

数据类的要求：为了确保生成的代码的一致性和有意义的行为，数据类必须满足以下要求

   - 主构造函数需要至少有一个参数；
   - 主构造函数的所有参数需要标记为 val 或 var；
   - 数据类不能是抽象、开放、密封或者内部的；
   - 数据类只能实现接口(在1.1之前)。
    
## 2.9  密封类：SealedClass

   - 密封类用来表示受限的类继承结构：当一个值为有限集中的 类型、而不能有任何其他类型时。
   - 在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。
   - 要声明一个密封类，需要在类名前面添加 `sealed` 修饰符
   - 虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明
   - 扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在 同一个文件中
   - 使用密封类的关键好处在于使用 `when` 表达式 的时候，如果能够 验证语句覆盖了所有情况，就不需要为该语句再添加一个 `else` 子句了
    
## 2.10 泛型：Generic

    -  `in`和`out`：`out`表示只输出，用于消费者；`int`表示输入，用于生产者
    - 上界`:`冒号之后指定的类型是上界
    
## 2.11 对象：Objects

有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类Java 用匿名内部类处理这种情况。 Kotlin 用对象表达式和对象声明对这个概念稍微概括了下
    

对象表达式：要创建一个继承自某个（或某些）类型的匿名类的对象

   - 如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在`:`后面的逗号分隔的列表指定
   - 匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。
   - 在匿名对象中添加的成员将无法访问。
    
对象声明

   - 对象声明不能在**局部作用域（即直接嵌套在函数内部）**，但是它们可以嵌套到其他对象声明或非内部类中。
    
伴生对象

   - 伴生对象的成员可通过只使用类名作为限定符来调用
   - 可以省略伴生对象的名称，在这种情况下将使用名称`companion`
   - 即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且还可以实现接口
   - 在JVM平台，如果使用 `@JvmStatic` 注解，可以将伴生对象的成员生成为真正的 静态方法和字段
   - 每个类，只能有一个伴生对象
    
对象表达式和对象声明之间的语义差异

   - 对象表达式是在使用他们的地方立即执行（及初始化）的
   - 对象声明是在第一次被访问到时延迟初始化的
   - 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配
    
    
## 2.12. 类的委托：ClassDelegation

有一些常见的属性类型，虽然我们可以在每次需要的时候手动实现它们， 但是如果能够为大家把他们只实现一次并放入一个库会更好。
    

适用于委托的属性

   - 延迟属性（lazy properties）: 其值只在首次访问时计算，
   - 可观察属性（observable properties）: 监听器会收到有关此属性变更的通
   - 把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。
    
Kotlin 支持 委托属性：语法是： `val/var <属性名>: <类型> by <表达式>`

   - 在 `by` 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。
   - 属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）
    

标准委托：Kotlin 标准库为几种有用的委托提供了工厂方法

   - 延迟属性 Lazy
   - 可观察属性 Observable：
   - 把属性储存在映射中：
   - 局部委托属性（自 1.1 起）
    
    
# 4 函数和lambda表达式：functions

## 4.1 函数：Functions

   - fun函数声明
   - 中缀表示法：**1，成员函数或扩展函数；2，只有一个参数；3，用`infix` 关键字标注**
   - 默认参数：参数可以有默认值
   - 命名参数：传入参数时可以指定参数名。调用 Java 函数时不能使用命名参数语法，因为 Java 字节码并不 总是保留函数参数的名称
   - 返回 Unit 的函数：如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个 值不需要显式返回
   - 可变数量的参数：函数的参数（通常是最后一个）可以用 `vararg` 修饰符标记
   - 函数作用域：**局部函数、 成员函数、顶层函数**
       
单表达式函数

   - 当函数返回单个表达式时，可以省略花括号并且在` = `符号之后指定代码体即可
   - 当返回值类型可由编译器推断时，显式声明返回类型是可选的
   - 有块代码体的函数必须始终显式指定返回类型
    
## 4.2 尾递归函数：TailRecursiveFunction

   - 当一个函数用 `tailrec` 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本。
   - 要符合 `tailrec` 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，
   - 不能用在 `try/catch/finally` 块中使用尾递归。目前尾部递归只在 JVM 后端中支持。
     
## 4.3 Lambda表达式：LambdaExpression

   - 高阶函数：高阶函数是将函数用作参数或返回值的函数。
   - 在 Kotlin 中有一个约定，如果函数的最后一个参数是一个函数，并且你传递一个`lambda` 表达式作为相应的参数，可以在圆括号之外指定它
    
Lambda表达式

   - `lambda` 表达式总是被大括号括着
   - 其参数（如果有的话）在` -> `之前声明（参数类型可以省略），
   - 函数体（如果存在的话）在` ->` 后面。
   - 如果 `lambda` 是该调用的是唯一参数，则调用中的圆括号可以完全省略。
   - 如果函数字面值只有一个参数， 那么它的声明可以省略（连同` ->`），其名称是 `it`。
    
 函数类型

   - 函数类型：对于接受另一个函数作为参数的函数，我们必须为该参数指定函数类型。
   - 比如less： ` (T, T) -> Boolean)`的类型为 接收两个T类型，返回一个Boolean
   - 可以定义一个变量，指向一个函数类型，比如：` val toStr: (num: Int) -> String = {  it.toString() }`
    
匿名函数

   - 一般`lambda` 表达式语法缺少指定函数的返回类型的能力。在大多数情况下，这是不必要的。因为返回类型可以自动推断出来。然而，如果确实需要显式指定，可以使用另一种语法： 匿名函数
   - 匿名函数的返回类型推断机制与正常函数一样：对于具有表达式函数体的匿名函数将自动 推断返回类型，而具有代码块函数体的返回类型必须显式 指定（或者已假定为 Unit）。
   - 匿名函数参数总是在括号内传递。 允许将函数留在圆括号外的简写语法仅适用于 `lambda `表达式。
   - `Lambda`表达式和匿名函数之间的另一个区别是非局部返回的行为。一个不带标签的` return` 语句 总是在用` fun `关键字声明的函数中返回。这意味着` lambda `表达式中的` return `将从包含它的函数返回，而匿名函数中的 `return` 将从匿名函数自身返回。

带接收者的函数字面值：Kotlin 提供了使用指定的接收者对象用函数字面值的功能。


## 4.4 内联函数：InlineFunction

   - 使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。
   - `inline` 修饰符影响函数本身和传给它的 `lambda` 表达式：所有这些都将内联 到调用处。
   - 内联可能导致生成的代码增加，但是如果我们使用得当（不内联大函数），它将在 性能上有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。
   - 如果只想被（作为参数）传给一个内联函数的 `lambda` 表达式中只有一些被内联，你可以用 `noinline `修饰符标记 一些函数参数
   - 可以内联的 `lambda` 表达式只能在内联函数内部调用或者作为可内联的参数传递， 但是 `noinline` 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等。
   - 非局部返回：在 Kotlin 中，我们可以只使用一个正常的、非限定的` return` 来退出一个命名或匿名函数。 这意味着要退出一个 `lambda` 表达式，我们必须使用一个标签，并且 在 lambda 表达式内部禁止使用裸 `return`，因为 `lambda` 表达式不能使包含它的函数返回
   - 非局部返回：但是如果 lambda 表达式传给的函数是内联的，该 return 也可以内联，所以它是允许的，这种返回（位于 lambda 表达式中，但退出包含它的函数）称为非局部返回
   - `rossinline` 修饰符标记
   - `reified` 修饰符标记
   - `内联属性
    
## 4.5 协程：Coroutine


# 5 其他特性

##  解构声明

componentN函数

## 使用集合

   - 可变与不可变
   - 不要可变的协变性
   - 函数式API
    
## 使用Range

   - 区间表达式由具有操作符形式 .. 的 `rangeTo` 函数辅以` in 和 !in` 形成。
   - 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。
   - 整型区间（`IntRange、 LongRange、 CharRange`）有一个额外的特性：它们可以迭代。 编译器负责将其转换为类似 Java 的基于索引的 for-循环而无额外开销。
   - 如果需要倒序迭代数字也很简单。可以使用标准库中定义的 downTo() 函数
   - 以不等于 1 的任意步长迭代数字？ 当然没问题， step() 函数有助于此
   - 要创建一个不包括其结束元素的区间，可以使用 until 函数
   - `rangeTo()`：整型类型的 rangeTo() 操作符只是调用 *Range 类的构造函数
   - `downTo()`：为任何整型类型对定义的
   - `reversed()`：为每个 `*Progression` 类定义的，并且所有这些函数返回反转后的数列
   - `step()`：扩展函数 step() 是为每个 `*Progression` 类定义的， 所有这些函数都返回带有修改了 `step` 值（函数参数）的数列。
   - 区间如何工作：区间实现了该库中的一个公共接口：`ClosedRange<T>`。
    
## 类型检查和转换

 - `is`和`!is`用于检查
 - `as`和`as?`用于转换
 
## this表达式

   - 在类的成员中，`this` 指的是该类的当前对象
   - 在扩展函数或者带接收者的函数字面值中， `this `表示在点左侧传递的接收者参数。
   -  如果` this` 没有限定符，它指的是最内层的包含它的作用域。要引用其他作用域中的 `this`，请使用 标签限定符
   -  要访问来自外部作用域的`this`（一个类 或者扩展函数， 或者带标签的带接收者的函数字面值）我们使用`this@label`，其中 `@label` 是一个 代指` this` 来源的标签
    
##  操作符重载

   - Kotlin 允许我们为自己的类型提供预定义的一组操作符的实现。
   - 一元操作符
   - 递增和递减
   - 二元操作
   - `In`操作符
   - 索引访问操作符
   - 调用操作符
   - 广义赋值
   - 相等与不等操作符
   - 比较操作符
   - 命名函数的中缀调用
    
##  空安全

可空类型与非空类型：Kotlin 的类型系统旨在消除来自代码空引用的危险。


许多编程语言（包括 Java）中最常见的陷阱之一是访问空引用的成员，导致空引用异常。在 Java 中，
这等同于 `NullPointerException` 或简称 NPE。Kotlin 的类型系统旨在从我们的代码中消除 NullPointerException

 NPE 的唯一可能的原因可能是：
 
  1. 显式调用 throw NullPointerException()
  2. 使用了 !! 操作符
  3. 外部 Java 代码导致的
  4. 对于初始化，有一些数据不一致（如一个未初始化的 this 用于构造函数的某个地方）
  
## 异常

   - kotlin 中所有异常类都是 Throwable 类的子孙类。 每个异常都有消息、堆栈回溯信息和可选的原因
   - Kotlin 没有受检的异常。
    
## 注解：KotlinAnnotation
 
 `annotation`声明关键字
    
## 反射

   - 类引用`::`
   - KProperty
   - KClass
   
##  类型安全的构建器

构建器类似Groovy中的生成器，使用要给DSL的语法来生成具有特定结构的对象

- 构建器很适合用来生成 XML、 布局 UI 组件、 描述 3D 场景
- 作用域控制：@DslMarker（自 1.1 起）

## 类别名

类型别名：类型别名为现有类型提供替代名称。 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。
类型别名不会引入新类型。 它们等效于相应的底层类型。 当你在代码中添加 typealias Predicate<T> 并使用 Predicate<Int> 时，Kotlin 编译器总是把它扩展为 (Int) -> Boolean。 因此，当你需要泛型函数类型时，你可以传递该类型的变量，反之亦然

            typealias NodeSet = Set<Network.Node>

# 6 与java互操作

Kotlin与java的交互： Kotlin 在设计时就考虑了 Java 互操作性。可以从 Kotlin 中自然地调用现存的 Java 代码，
并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。

## Kotlin中调用Java

- 遵循 Java 约定的 getter 和 setter 的方法（名称以 get 开头的无参数方法和以 set 开头的单参数方法）在 Kotlin 中表示为属性。
- 如果 Java 类只有一个 setter，它在 Kotlin 中不会作为属性可见，因为 Kotlin 目前不支持只写（set-only）属性。
- 如果一个 Java 方法返回 void，那么从 Kotlin 调用时中返回 Unit。 万一有人使用其返回值，它将由 Kotlin 编译器在调用处赋值， 因为该值本身是预先知道的（是 Unit）
- 一些 Kotlin 关键字在 Java 中是有效标识符：in、 object、 is 等等。 如果一个 Java 库使用了 Kotlin 关键字作为方法，你仍然可以通过反引号（`）字符转义它来调用该方法
- 空安全和平台类型：Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。对这种类型的空检查会放宽， 因此它们的安全保证与在 Java 中相同
- 平台类型表示法：T! 表示“T 或者 T?”
- 已映射类型
- Kotlin 中的 Java 泛型
- Java 数组：与 Java 不同，Kotlin 中的数组是不型变的。这意味着 Kotlin 不允许我们把一个 Array<String> 赋值给一个 Array<Any>， 从而避免了可能的运行时故障。
- 对于每种原生类型的数组都有一个特化的类（IntArray、 DoubleArray、 CharArray 等等）来处理这种情况。 它们与 Array 类无关，并且会编译成 Java 原生类型数组以获得最佳性能。
- Java可变参数

 ## Java中调用Kotlin
 
- 属性
- 包：在 `org.foo.bar` 包内的` example.kt `文件中声明的所有的函数和属性，包括扩展函数， 都编译成一个名为 `org.foo.bar.ExampleKt `的 Java 类的静态方法
- 实例字段：`@JvmField`
- 静态方法
- 可见性
- KClass
- 用 `@JvmName `解决签名冲突
- 生成重载
- 受检异常
- 空安全性
- 型变的泛型
- `Nothing` 类型翻译
