# 3 函数和lambda表达式：functions

---
## 3.1 函数：Functions

   - fun函数声明
   - 中缀表示法：**1，成员函数或扩展函数；2，只有一个参数；3，用`infix` 关键字标注**
   - 默认参数：参数可以有默认值
   - 命名参数：传入参数时可以指定参数名。调用 Java 函数时不能使用命名参数语法，因为 Java 字节码并不 总是保留函数参数的名称
   - 返回 Unit 的函数：如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个 值不需要显式返回
   - 可变数量的参数：函数的参数（通常是最后一个）可以用 `vararg` 修饰符标记
   - 函数作用域：**局部函数、 成员函数、顶层函数**
       
单表达式函数

   - 当函数返回单个表达式时，可以省略花括号并且在` = `符号之后指定代码体即可
   - 当返回值类型可由编译器推断时，显式声明返回类型是可选的
   - 有块代码体的函数必须始终显式指定返回类型

---
## 3.2 尾递归函数：TailRecursiveFunction

   - 当一个函数用 `tailrec` 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本。
   - 要符合 `tailrec` 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，
   - 不能用在 `try/catch/finally` 块中使用尾递归。目前尾部递归只在 JVM 后端中支持。

---
## 3.3 Lambda表达式：LambdaExpression

   - 高阶函数：高阶函数是将函数用作参数或返回值的函数。
   - 在 Kotlin 中有一个约定，如果函数的最后一个参数是一个函数，并且你传递一个`lambda` 表达式作为相应的参数，可以在圆括号之外指定它
    
Lambda表达式

   - `lambda` 表达式总是被大括号括着
   - 其参数（如果有的话）在` -> `之前声明（参数类型可以省略），
   - 函数体（如果存在的话）在` ->` 后面。
   - 如果 `lambda` 是该调用的是唯一参数，则调用中的圆括号可以完全省略。
   - 如果函数字面值只有一个参数， 那么它的声明可以省略（连同` ->`），其名称是 `it`。
    
 函数类型

   - 函数类型：对于接受另一个函数作为参数的函数，我们必须为该参数指定函数类型。
   - 比如less： ` (T, T) -> Boolean)`的类型为 接收两个T类型，返回一个Boolean
   - 可以定义一个变量，指向一个函数类型，比如：` val toStr: (num: Int) -> String = {  it.toString() }`
    
匿名函数

   - 一般`lambda` 表达式语法缺少指定函数的返回类型的能力。在大多数情况下，这是不必要的。因为返回类型可以自动推断出来。然而，如果确实需要显式指定，可以使用另一种语法： 匿名函数
   - 匿名函数的返回类型推断机制与正常函数一样：对于具有表达式函数体的匿名函数将自动 推断返回类型，而具有代码块函数体的返回类型必须显式 指定（或者已假定为 Unit）。
   - 匿名函数参数总是在括号内传递。 允许将函数留在圆括号外的简写语法仅适用于 `lambda `表达式。
   - `Lambda`表达式和匿名函数之间的另一个区别是非局部返回的行为。一个不带标签的` return` 语句 总是在用` fun `关键字声明的函数中返回。这意味着` lambda `表达式中的` return `将从包含它的函数返回，而匿名函数中的 `return` 将从匿名函数自身返回。

带接收者的函数字面值：Kotlin 提供了使用指定的接收者对象用函数字面值的功能。

---
## 3.4 内联函数：InlineFunction

   - 使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。
   - `inline` 修饰符影响函数本身和传给它的 `lambda` 表达式：所有这些都将内联 到调用处。
   - 内联可能导致生成的代码增加，但是如果我们使用得当（不内联大函数），它将在 性能上有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。
   - 如果只想被（作为参数）传给一个内联函数的 `lambda` 表达式中只有一些被内联，你可以用 `noinline `修饰符标记 一些函数参数
   - 可以内联的 `lambda` 表达式只能在内联函数内部调用或者作为可内联的参数传递， 但是 `noinline` 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等。
   - 非局部返回：在 Kotlin 中，我们可以只使用一个正常的、非限定的` return` 来退出一个命名或匿名函数。 这意味着要退出一个 `lambda` 表达式，我们必须使用一个标签，并且 在 lambda 表达式内部禁止使用裸 `return`，因为 `lambda` 表达式不能使包含它的函数返回
   - 非局部返回：但是如果 lambda 表达式传给的函数是内联的，该 return 也可以内联，所以它是允许的，这种返回（位于 lambda 表达式中，但退出包含它的函数）称为非局部返回
   - `rossinline` 修饰符标记
   - `reified` 修饰符标记
   - `内联属性