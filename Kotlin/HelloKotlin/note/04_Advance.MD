# 4 其他特性

---
##  解构声明

componentN函数

---
## 使用集合

   - 可变与不可变
   - 不要可变的协变性
   - 函数式API

---
## 使用Range

   - 区间表达式由具有操作符形式 .. 的 `rangeTo` 函数辅以` in 和 !in` 形成。
   - 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。
   - 整型区间（`IntRange、 LongRange、 CharRange`）有一个额外的特性：它们可以迭代。 编译器负责将其转换为类似 Java 的基于索引的 for-循环而无额外开销。
   - 如果需要倒序迭代数字也很简单。可以使用标准库中定义的 downTo() 函数
   - 以不等于 1 的任意步长迭代数字？ 当然没问题， step() 函数有助于此
   - 要创建一个不包括其结束元素的区间，可以使用 until 函数
   - `rangeTo()`：整型类型的 rangeTo() 操作符只是调用 *Range 类的构造函数
   - `downTo()`：为任何整型类型对定义的
   - `reversed()`：为每个 `*Progression` 类定义的，并且所有这些函数返回反转后的数列
   - `step()`：扩展函数 step() 是为每个 `*Progression` 类定义的， 所有这些函数都返回带有修改了 `step` 值（函数参数）的数列。
   - 区间如何工作：区间实现了该库中的一个公共接口：`ClosedRange<T>`。

---
## 类型检查和转换

 - `is`和`!is`用于检查
 - `as`和`as?`用于转换

---
## this表达式

   - 在类的成员中，`this` 指的是该类的当前对象
   - 在扩展函数或者带接收者的函数字面值中， `this `表示在点左侧传递的接收者参数。
   - 如果` this` 没有限定符，它指的是最内层的包含它的作用域。要引用其他作用域中的 `this`，请使用 标签限定符
   - 要访问来自外部作用域的`this`（一个类 或者扩展函数， 或者带标签的带接收者的函数字面值）我们使用`this@label`，其中 `@label` 是一个 代指` this` 来源的标签

---
##  操作符重载

   - Kotlin 允许我们为自己的类型提供预定义的一组操作符的实现。
   - 一元操作符
   - 递增和递减
   - 二元操作
   - `In`操作符
   - 索引访问操作符
   - 调用操作符
   - 广义赋值
   - 相等与不等操作符
   - 比较操作符
   - 命名函数的中缀调用

---
##  空安全

可空类型与非空类型：Kotlin 的类型系统旨在消除来自代码空引用的危险。

许多编程语言（包括 Java）中最常见的陷阱之一是访问空引用的成员，导致空引用异常。在 Java 中，
这等同于 `NullPointerException` 或简称 NPE。Kotlin 的类型系统旨在从我们的代码中消除 NullPointerException

 NPE 的唯一可能的原因可能是：
 
  1. 显式调用 throw NullPointerException()
  2. 使用了 !! 操作符
  3. 外部 Java 代码导致的
  4. 对于初始化，有一些数据不一致（如一个未初始化的 this 用于构造函数的某个地方）

---
## 异常

   - kotlin 中所有异常类都是 Throwable 类的子孙类。 每个异常都有消息、堆栈回溯信息和可选的原因
   - Kotlin 没有受检的异常。

---
## 注解：KotlinAnnotation
 
 `annotation`声明关键字

---
## 反射

   - 类引用`::`
   - KProperty
   - KClass

---
##  类型安全的构建器

构建器类似Groovy中的生成器，使用要给DSL的语法来生成具有特定结构的对象

- 构建器很适合用来生成 XML、 布局 UI 组件、 描述 3D 场景
- 作用域控制：@DslMarker（自 1.1 起）

---
## 类别名

类型别名：类型别名为现有类型提供替代名称。 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。
类型别名不会引入新类型。 它们等效于相应的底层类型。 当你在代码中添加 typealias Predicate<T> 并使用 Predicate<Int> 时，
Kotlin 编译器总是把它扩展为 (Int) -> Boolean。 因此，当你需要泛型函数类型时，你可以传递该类型的变量，反之亦然

            typealias NodeSet = Set<Network.Node>
