# 表达式

表达式由一个或多个运算对象组成，对表达式就值将会得到一个结果。

---
## 避免陷阱

```
if(i =j){//判断条件是 i的值

}
if(i == j){//判断条件是i == j

}
```

---
## sizeof

sizeof返回一条表达式或一个类型名字所占的字节数。

---
## 语句

- if语句
- while
- 传统for
- 范围for
- switch：switch 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
- goto：goto语句的作用是从goto语句无条件跳转到**同函数**内的另一条语句。不要在程序中使用goto语句。
- TRY：用于处理异常。

---
## 标准异常

异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。
异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：`try、catch、throw`。

```
try{
   // 保护代码
}catch( ExceptionName e1 ){
   // catch 块
}catch( ExceptionName e2 ){
   // catch 块
}catch( ExceptionName eN ){
   // catch 块
}
```


C++ 提供了一系列标准的异常，它们被定义在四个头文件中。

- exception头文件中定义了最通用的异常类exception，只报告异常的发生，不提供任何信息
- stdexcept头文件定义了几种常用的异常
- new头文件定义了bad_alloc异常类型
- type_info头文件定义了bad_cast异常

常见异常如下所示：

- `std::exception`	该异常是所有标准 C++ 异常的父类。
- `std::bad_alloc`	该异常可以通过 new 抛出。
- `std::bad_cast`	该异常可以通过 dynamic_cast 抛出。
- `std::bad_exception`	这在处理 C++ 程序中无法预期的异常时非常有用。
- `std::bad_typeid`	该异常可以通过 typeid 抛出。
- `std::logic_error`	理论上可以通过读取代码来检测到的异常。
- `std::domain_error`	当使用了一个无效的数学域时，会抛出该异常。
- `std::invalid_argument`	当使用了无效的参数时，会抛出该异常。
- `std::length_error`	当创建了太长的 std::string 时，会抛出该异常。
- `std::out_of_range`	该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。
- `std::runtime_error`	理论上不可以通过读取代码来检测到的异常。
- `std::overflow_error`	当发生数学上溢时，会抛出该异常。
- `std::range_error`	当尝试存储超出范围的值时，会抛出该异常。
- `std::underflow_error`	当发生数学下溢时，会抛出该异常。	

只能以默认初始化的方式初始化exception、bad_alloc、bad_cast异常，不能为它们提供任何初始化值，而其他异常在初始化时，需要提供string类型的异常信息。

---
## 显式类型转换

有时候需要将一种数据类型强转为其他类型。

### 命名的强制类型转换

一个命名的强制类型的形式如下：
```
cast-name<type>(expression);
```
type是转换的目标类型，而expression是被转换的值。

cast-name包括
- static_cast：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast
- dynamic_cast：运行时的类型识别
- const_cast：只能改变运算对象的底层const
    - 将常量转换为非常量，我们称为去掉const性质
    - 如果一个对象本身不是const的，去掉const性质后获得的写权限是合法的
    - 如果一个对象是const的，使用const_cast执行写操作就会产生未定义的效果
- reinterpret_cast：通常为运算对象的位运算模式提供较低层次的重新解释。
```
int *p
char *pc = reinterpret_cast<char*>(p)
```

### 旧式的类型转换

早期版本的c++中，包含两种强制类型转换语法：
- `type(expr)` 函数形式的类型转换
- `(type)expr` c风格的类型转换

旧式的类型转换分别具有static_cast、const_cast、reinterpret_cast相似的行为，旧式的转换类型可以替换成命名强制类型转换，如果换成static_cast、const_cast
合法，则其行为与对应的命名转换一致，否则旧式类型转换执行与reinterpret_cast相似的行为。

```
int *ip;
char *pc = (int*)ip;
```
效果与reinterpret_cast一样。