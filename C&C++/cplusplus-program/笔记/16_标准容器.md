# 标准容器


## 1 顺序容器

### 1.1 顺序容器概述

C++提供了以下容器：

- vector：可变大小的数组，支持随机访问，尾部之外的位置插入元素速度可能很慢   
- deque：双端队列，支持随机访问，头尾位置插入元素速度快
- list：双向链表
- forward_list：单向链表，forward_list设计目的是达到与手写单向链表数据结构相当的性能
- array：固定大小的数组，不同添加和删除元素，相比数组，array是一种更加安全更易使用的数组类型
- string：与vector类似的数组，专门用于存储char

**通常情况下应该使用vector，除非你有更好的选择**

### 1.2 容器库概述

容器上的操作可以整理为：
- 所有容器都支持的操作
- 针对特定容器支持的操作
- 大多数元素都可以保存在容器中，但某些容器的操作对容器元素的类型有特殊要求

类类型没有默认构造函数时，存储该类型容器的初始化：
```
//假设noDefault没有默认的构造函数
vector<noDefault> v1(10, init);//正确，提供了初始化器
vector<noDefault> v2(10);//错误，必须提供初始化器
```

C++ 语言中，大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：

- 元素类型必须支持赋值运算
- 元素类型的对象必须可以复制

引用类型、输入输出(IO)标准库类型、auto_ptr类型，这些类型不能作为容器元素。


#### 迭代器

- 构成范围的begin和end迭代器
- forward-list迭代器不支持`--`操作
- 迭代器是左闭右开的区间
- last不指向任何元素，而是一个尾部标识

```
c.begin()	返回一个迭代器,它指向容器 c 的第一个元素
c.end()	返回一个迭代器,它指向容器 c 的最后一个元素的下一位置
c.rbegin()	返回一个逆序迭代器,它指向容器 c 的最后一个元素
c.rend()	返回一个逆序迭代器,它指向容器 c 的第一个元素前面的位置
c.cbegin()、c.cend()
```

由 end 操作返回的迭代器指向 vector 的末端元素的下一个 。“超出末端迭代器”（off-the-end iterator）。
表明它指向了一个不存在的元素。如果 vector 为空，begin 返回的迭代器与 end 返回的迭代器相同。

#### 容器类型成员

类型别名成员：

- `iterator`
- `const_iterator`
- `size_type`无符号整型，足以存储此容器类型的最大可能容器长度
- `difference_type` 足够保存两个迭代器之间的距离
- `value_type`元素类型
- `reference`元素的 左值类型，与`value_type&`含义相同
- `const_reference`元素的常量左值类型，等效于` const value_type&`

反响迭代器的额外成员：

- `reverse_iterator`
- `const_reverse_iterator`
- `c.rbegin()、c.rend()` 返回逆序迭代器
- `c.crbegin()、c.crend()`返回常量逆序迭代器

 begin和end成员，r开头方法获取反向迭代器，c开头方法获取常量迭代器


### 容器定义和初始化

除array，每个容器都有默认构造方法

- `C c;`默认构造函数(array除外)
- `c c1(c2);`拷贝c2中的元素到c1
- `C c(b , e);`构造c，将迭代器b和e指定范围的元素拷贝到c(array不支持)
- `C c{a, b, c...};`列表初始化

除上面操作外，顺序容器的初始化方式还有：

- `C seq(n)` seq包含了n个元素，这些元素进行值初始化
- `C seq(n, t)` seq包含了n个初始化值为t的元素

为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。

#### 将一个容器初始化为另一个容器的拷贝

将一个容器初始化为另一个容器的拷贝有两种方法：

- 直接拷贝整个容器
- 拷贝一个由迭代器指定的范围(array除外)

```
list<string>  list1 = {"a", "b", "c"};
vector<const  char*>  vector1 = {"a", "b", "c"};

deque<string> list2(list1);//错误，容器类型不匹配
vector<string>  vector2(vector1);//错误，元素类型必须匹配

forward_list<string> list3(vector1.begin(), vector1.end());//正确，const  char*可以转换为string
```

#### 标准array

```
array<int, 10> ia1;//正确的类型，元素执行默认初始化
array<int, 10> ia2;
array<int, 10> ia3 = {42};//第一个元素42，其余0
array<int> ia4;//错误，array<int>不是一个类型

//相同类型的array间允许赋值
ia1 = ia2;
```

### 容器的赋值与swap

赋值：
- `c1 = c2;`删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和 c2 的类型(包括容器类型和元素类型)必须相同
- `c1 = {a, b, c...};`初始化列表
- `a.swap(b);`
- `swap(a, b);`交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素， c2 中存放的则是 c1 原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 复制到 c1 的操作快

顺序容器assign(不适用于关联容器和array)：

- `c.assign(b,e)`	重新设置 c 的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器
- `c.assign(n,t)`	将容器 c 重新设置为存储 n 个值为 t 的元素
- `c.assign(il)`	将容器 c 中存储的元素替换为初始化列表il中的元素

注意：

- 使用非成员版本的swap是一个好习惯
- 赋值和 assign 操作使左操作数容器的所有迭代器、引用、指针失效
- swap 操作则不会使迭代器失效。完成 swap 操作后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。(array和string除外)
- 除array外，swap 只是交换了两个容器的内部数据结构
- 除array外，swap不对任何元素进行拷贝、删除、插入操作，可以保证在常数时间内完成

#### 容器大小操作
 
- `c.size()	`返回容器 c 中的元素个数。返回类型为 c::size_type
- `c.max_size()	`返回容器 c 可容纳的最多元素个数，返回类型为 c::size_type
- `c.empty()`	返回标记容器大小是否为 0 的布尔值
- `c.resize(n)`	调整容器 c 的长度大小，使其能容纳 n 个元素，如果 n < c.size()，则删除多出来的元素;否则，添加采用值初始化的新元素
- `c.resize(n,t)`	调整容器 c 的长度大小，使其能容纳 n 个元素。所有新添加的元素值都为 t

注意：
- resize不适用与array
- 如果resize缩小容器，则执行被删除元素的迭代器、引用、指针都会失效，对vector、string、deque进行resize可能导致迭代器、引用、指针失效

#### 关系运算符

所有的容器类型都支持用关系操作符来实现两个容器的比较。但比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。
容器的比较是基于容器内元素的比较。容器的比较使用了元素类型定义的同一个关系操作符：两个容器做 != 比较使用了其元素类型定义的 != 操作符。
如果容器的元素类型不支持某种操作符，则该容器就不能做这种比较运算。

- 如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。
- 如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。
- 如果两个容器都不是对方的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。

- `==、!=`所有容器都支持
- `<、<= 、>、>=`无序关联容器不支持


### 1.3 顺序容器操作

#### 在顺序容器中添加元素(array除外)

- `c.push_back(t)`	在容器 c 的前端添加值为 t 的元素。返回 void 类型
- `c.push_front(t)`	在容器 c 的尾部添加值为 t 的元素。返回 void 类型。只适用于 list 和 deque 容器类型
- `c.insert(p, t)、c.emplace(p, t);`	在迭代器 p 所指向的元素前面插入值为 t 的新元素。返回指向新添加元素的迭代器
- `c.insert(p, n, t)`	在迭代器 p 所指向的元素前面插入 n 个值为 t 的新元素。返回 void 类型
- `c.insert(p, b, e)`	在迭代器 p 所指向的元素前面插入由迭代器 b 和 e 标记的范围内的元素。返回 void 类型

#### 访问元素

- `c.back()`	返回容器 c 的最后一个元素的引用。如果 c 为空，则该操作未定义
- `c.front()`	返回容器 c 的第一个元素的引用。如果 c 为空，则该操作未定义
- `c[n]`	返回下标为 n 的元素的引用。如果 n < 0 或 n >= c.size()，则该操作未定义。只适用于 vector 和 deque 容器
- `c.at(n)`	返回下标为 n 的元素的引用。如果下标越界，则该操作未定义。只适用于 vector 和 deque 容器

#### 删除元素

- `c.erase(p)`	删除迭代器 p 所指向的元素。返回一个迭代器，它指向被删除元素后面的元素。如果 p 指向容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置。如果 p 本身就是指向超出末端的下一位置的迭代器，则该函数未定义。
- `c.erase(b, e)`	删除迭代器 b 和 e 所标记的范围内所有的元素。返回一个迭代器，它指向被删除元素段后面的元素。如果 e 本身就是指向超出末端的下一位置的迭代器，则返回的迭代器也指向容器的超出末端的下一位置。
- `c.clear()`	删除容器 c 内的所有元素。返回 void。
- `c.pop_back()`	删除容器 c 的最后一个元素。返回 void。如果 c 为空容器，则该函数未定义。
- `c.pop_front()`	删除容器 c 的第一个元素。返回 void。如果 c 为空容器，则该函数未定义。只适用于 list 或 deque 容器

####访问成员函数返回的是引用

```
auto &v = c.back();
```

#### 下表操作与安全的随机访问

```
vector<string> vec;//空vector
cout << vev[0];//运行时错误，ves中没有元素
cout << vec.at(0);//抛出一个out_ot_range异常
```

#### forward_list操作

由于forward_list是单向链表，定义了专门针对forward_list操作的函数。


#### 容器操作可能使迭代器失效


### 1.4 容器如何增长

#### 管理容器的大小

### 1.5 string操作

### 1.6 容器适配器




