---
## 1 基本内置类型

C++定义了一套包括算术(arithmetic)类型和空类型(void)在内的基本数据类型。

- 算术类型包括：整数、布尔类型、字符、和浮点类型。
- 空类型不对应任何具体的值，仅用于一些特殊场合。


不要混用有符号类型的数据和无符号类型的数据
```
    int va = -1;
    unsigned int vb = 1;
    int vc = va * vb;//此时va会自动转为为无符号类型的整数
```

---
## 2 复合类型

复合类型是指基于其他基本类型定义的类型。比如**引用和指针**。

### 2.1 引用

一般使用的术语**引用**指的是左值引用。引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成`&d`(每个引用都必须以&开头)来定义引用类型，其中d是声明的变量名。定义引用类型时，引用类型必需被初始化。引用并非对象，它只是为一个已经存在的对象取另一个名字。


引用类型一经被初始化，就一直和它的初始值对象绑定在一起。


### 2.2 指针
 
指针是指向另一种类型的复合类型，与引用不同的是：

- 指针本身是一个对象，允许对指针进行赋值和拷贝
- 指针无需在定义时初始化

指针值有以下四种状态：

- 指向一个对象
- 指向临近对象所占空间的下一个位置
- 空指针，没有指向任何对象
- 无效指针

NULL是一个预处理变量，用来给指针赋值，定义在`cstdlib`中，它的值是0。

`void*`指针是一种特殊的指针类型，可用于存放任意对象的地址。

---
## 2.3 const限定符

使用const用于定义常量，默认状态下，const仅在文件内有效。如果想在多个文件内共享const变量，必需在变量的定义之前添加`extern`关键字。

---
## 2.4  constexpr常量表达式

常量表达式是指值不会改变且在编译阶段就能计算结果的表达式。

```
const int a = 32;//a是一个常量表达式
const int b = a+1;//b是一个常量表达式
int c = 32;//c不是是一个常量表达式，它没有被const修饰
const int szie = get_size();//size不是一个常量表达式，其值在运行时才能确认。
```

C++11新标准规定，允许将变量声明为constexpr类型，以便编译器来校验变量的值是否为一个常量表达式。声明constexpr的变量一定是常量，且必需使用常量表达式。

### 指针和constexpr

在constexpr声明中如果使用了指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

```
    const int *pA = nullPtr;//pA是一个指向整型常量的指针
    constexpr int *pB = nullPtr;//pB是一个指向整型的常量指针
```

---
## 2.5 处理类型

###  类型别名

使用typedef可以给数据类型起新的名字。

### auto类型说明符

C++11新标准引入了auto类型说明符，用它可以让编译器替开发者分析表达式所属的类型。

### decltype类型指示符

如果系统从表达式推断出要定义的类型，但是又不希望使用该表达式的结果作为初始化值，则可以使用C++11引入的第二种类型说明符decltype。

```
decltype(f()) value = x;//value的类型就是f的返回值类型。
```


---
## 2.6 自定义数据结构

从最基本的层面理解，数据结构就是把一组相关的数据元素组织起来然后使用它们的粗略和方法。
C++允许用户以类的形式自定义数据类型。

- 可以使用struct关键字定义数据结构
- C++11新的规定，可以为类内数据成员定义初始化值
- 类(数据机构)的定义应该放在头文件中。每个头文件都应该使用预编译指定防止重复引用。