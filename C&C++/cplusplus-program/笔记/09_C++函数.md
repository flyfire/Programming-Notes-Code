# 函数

---
## 函数声明

- 函数在使用前也需要声明
- 如果一个函数永远不会被调用，可以只有声明，没有实现
- 与变量一样，函数声明应该放在头文件中，函数的实现应该放在源文件中
- 在函数中声明函数是一个不好的习惯

---
## 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式：

- **传值调用**：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。
- **指针调用**：该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
- **引用调用**：该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。

引用与常量参数：

- 把参数声明为引用类型，可以避免是实参被拷贝
- 如果无需修改参数值，最好把参数声明为常量。
- 使用普通引用而非常量引用极大的限制了函数能接受的实参类型，这个函数只能接受非常量类型

---
## 可变参数

为了编写 能处理不同数量实参的参数，C++11提供了两种方法：

- 如果实参的类型相同，可以传递initializer_list的标准类型库
- 如果实参类型不相同，可以使用可变参数模板

另外，C++还有一种特殊的形参类型(省略符)，它可以传递可变数量的实参，`...`省略符一般是为了c++访问某些特殊的c代码而使用。

---
## 返回值

返回一个值的方式和初始化一个变量的方式完全一样：返回值用于初始化调用点的一个临时变量，该临时变量就是函数调用的结果。

- 一般情况下，返回值将被拷贝到调用点
- 如果函数返回的时引用类型，则不会存在拷贝  
- 不要返回局部对象的指针或引用。

要确保返回值的安全，可以问自己：**引用所引的是在函数之前已经存在的哪个对象？**

C++ 11规定，函数可以返回花括号包围的值的列表。

---
## Lambda 函数与表达式

C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。
Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式是：

- `[capture](parameters)->return-type{body}`
- `[capture](parameters){body}` 没有返回值类型

示例：
```
[](int x, int y){ return x < y ; }
[]{ ++global_x; } 
[](int x, int y) -> int { int z = x + y; return z + x; }
```

在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。C++闭包变量传递有传值和传引用的区别。可以通过前面的[]来指定：

```
[]                // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y]        // x以传值方式传入（默认），y以引用方式传入。
[&]             // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]             // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]         // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z]       // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

对于*[=]或[&]*的形式，lambda 表达式可以直接使用 this 指针。但是，对于*[]*的形式，如果要使用 this 指针，必须显式传入：

```
[this]() { this->someFunc(); }();
```

---
## 函数重载

### 注意重载与const参数形式

重复声明：
```
Record lookup(Phone)
Record lookup(const Phone)

Record lookup(Phone*)
Record lookup(Phone* const)//Phone* const是常量的指针
```

函数重载
```
Record lookup(Phone&)
Record lookup(const Phone&)

Record lookup(Phone*)
Record lookup(const Phone*)//const Phone*是常量类型的指针
```

---
## 默认参数

当定义一个函数时，可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。
这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。

局部变量不能作为参数的默认参数，初次之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参。



--- 
## 内联函数和constexpr函数

- 将函数声明为inline则表示该函数为内联函数，内联函数可以避免程序调用函数的开心，但是内联只是向编译器发送一个请求，编译器可以选择忽略这个请求。
- constexpr函数可用于常量表达式，执行初始化任务时，编译器把对constexpr函数的调用替换成结果值，为了能在编译过程中展开，constexpr函数被
隐式的声明为内联函数，声明constexpr函数有如下规则
    - 函数的返回值和所有形参类型都必须是字面值类型
    - 函数有且只有一条return语句
- 内联函数和constexpr函数可以被多次定义(多次定义必须完全一致)，内联函数和constexpr函数应该放在头文件中


---
## 调试

- assert预处理宏
- assert的行为以依赖一个名为NDEBUG的预处理变量，如果定义了NDEBUG则assert什么都不做，默认没有定义，我们可以在程序中定义这个宏，让assert不再工作。

其他预定义宏：
- `_ _fun_ _` 当前函数名
- `_ _FILE_ _` 存放文件名的字符串字面值
- `_ _LINE_ _` 存放当前行号
- `_ _TIME_ _` 存放文件编译时间
- `_ _DATE_ _` 存放文件编译日期


---
## 函数指针

- 函数的类型与=由它的返回值和参数共同决定，与函数名无关
- 函数指针指向一个函数
- 注意区分函数指针与返回指针的函数

```
bool (*pf)(const string &,const string &) 函数指针
bool *pf(const string &,const string &) 返回指针的函数

通过函数指针调用函数
pf("hello", "world"); 可以不解引用直接调用
(*pf)("hello", "world"); 解引用后调用
```
