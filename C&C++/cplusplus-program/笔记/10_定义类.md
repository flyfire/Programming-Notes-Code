# 定义类

c++中使用**struct**或**class**定义类，struct与class唯一的区别就是默认的访问权限不一样。
- struct的一个访问说明符之前所有的成员都是public的
- class的一个访问说明符之前所有的成员都是private的

C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。

## 成员函数

类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员。
类成员函数可以只在类内声明，然后在类外使用范围解析运算符 :: 来定义，可以直接定义在类中，
在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符

## 访问修饰符

- `public`公有成员在程序中类的外部是可访问的。可以不使用任何成员函数来设置和获取公有变量的值
- `private`私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。
- `protected`保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

## 析构函数

类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。
析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，
它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

## C++ 拷贝构造函数


拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。
具有单个形参，该形参（常用const修饰）是对该类类型的引用。
当定义一个新对象并用一个同类型的对象对它进行初始化时，将显示使用拷贝构造函数。
当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用拷贝构造函数。

拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

什么时候定义拷贝构造函数：

- 如果在类中没有定义拷贝构造函数，编译器会自行定义一个。
- 如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

拷贝构造函数的最常见形式如下：

```
classname (const classname &obj) {
   // 构造函数的主体
}
```

### C++支持两种初始化形式

- 拷贝初始化 int a = 5; 
- 直接初始化 int a(5);

对于其他类型没有什么区别，对于类类型直接初始化直接调用实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数

```
A x(2);　　//直接初始化，调用构造函数
A y = x;　　//拷贝初始化，调用拷贝构造函数
```

## 友元

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。
尽管友元函数的原型有在类的定义中出现过，**但是友元函数并不是成员函数**。

- 友元可以是一个函数，该函数被称为友元函数
- 友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 `friend`修饰符


## this

在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。

## 类的静态成员

### 静态成员变量

我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

不能在类中直接初始化静态成员:
```
class Box {
public:
    static int objectCount = 4;//不合法
};

//可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化
int Box::objectCount = 0;
```

### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，
静态函数只要使用类名加范围解析运算符` :: `就可以访问。