# 动态对象

在C++中，**尽量用 `new` 和 `delete` 而不用 `malloc` 和 `free`**。
malloc 和 free(及其变体)会产生问题的原因在于它们太简单：他们不知道构造函数和析构函数。

---
## 1 动态对象

动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new 表达式返回指向新创建对象的指针，
然后通过该指针来访问此对象。动态创建的对象需要程序员手动释放，否则会造成内存泄露。

### 初始化

动态创建的对象可用初始化变量的方式实现初始化，如果不提供显式初始化，动态创建的对象与在函数内定义的变量初始化方式相同。
**对于类类型的对象，用该类的默认构造函数初始化**；而内置类型的对象则无初始化。


```
void dynamicObject(){
    int i;              // i 未知
    int *pi = new int;  // pi指向一个未知的int值
    int i(1024);              // i = 1024 
    int *pi = new int(1024);  // pi指向一个int，值为1024
    string s(10, '9');                   //  s 为 "9999999999" 
    string *ps = new string(10, '9');    // *ps 为 "9999999999"
    
    string *ps = new string(); //空字符串
    int *pi = new int();  // pi指向初始化值为0的int
}
```

所以就像总是要初始化定义为变量的对象一样，在动态创建对象时，总是对它做初始化也是一个好办法。

### 释放

动态创建的对象用完后，程序员必须显式地将该对象占用的内存返回给自由存储区。C++ 提供了 delete 表达式释放指针所指向的地址空间。
但是，**如果指针指向不是用 new 分配的内存地址，则在该指针上使用 delete 是不合法的。**
同时C++ 没有明确定义如何释放指向不是用 new 分配的内存地址的指针。

### 零值指针的删除

如果指针的值为 0，则在其上做 delete 操作是合法的：
```
int *ip = 0; 
delete ip;
```

### 悬垂指针

执行语句：`delete p;`后，p 变成没有定义。在很多机器上，尽管 p 没有定义，但仍然存放了它之前所指向对象的地址 ，
然而 p 所指向的内存已经被释放，因此 p 不再有效。 删除指针后，该指针变成**悬垂指针** 。
悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。
**一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清楚地表明指针不再指向任何对象。**


### const 对象的动态分配和回收

C++ 允许动态创建 const 对象，与其他常量一样，动态创建的 const 对象必须在创建时初始化，并且一经初始化，其值就不能再修改。

```
//由于 new 返回的地址上存放的是 const 对象，因此该地址只能赋给指向 const 的指针。
const int *pci = new const int(1024);
```

尽管程序员不能改变 const 对象的值，但可撤销对象本身。如同其他动态对象一样， const 动态对象也是使用删除指针来释放的。

### 动态内存的管理注意

- **delete指向动态分配内存的指针失败**，因而无法将该块内存返还给自由存储区。删除动态分配内存失败称为“内存泄漏（dynamic_memory leak）”。
内存泄漏很难发现，一般需等应用程序运行了一段时间后，耗尽了所有内存空间时，内存泄漏才会显露出来。
- **读写已删除的对象**。如果删除指针所指向的对象之后，将指针置为 0 值，则比较容易检测出这类错误。
- **对同一个内存空间使用两次 delete 表达式**。当两个指针指向同一个动态创建的对象，删除时就会发生错误。
如果在其中一个指针上做 delete 运算，将该对象的内存空间返还给自由存储区，然后接着 delete 第二个指针，此时则自由存储区可能会被破坏。


---
## 2 动态数组

数组类型的变量有三个重要的限制：**1、数组长度固定不变；2、在编译时必须知道其长度；3、数组只在定义它的块语句内存在。**
但是实际的编程任务中，往往需要在运行时动态地分配数组。虽然数组长度是固定的，但动态分配的数组不必在编译时知道其长度，
与数组变量不同，动态分配的数组将一直存在，直到程序显式释放它为止。

创建数组后，`new` 将返回指向数组第一个元素的指针，动态分配数组时，如果数组元素具有类类型，
**将使用该类的默认构造函数实现初始化**；如果数组元素是内置类型，则**无初始化**

```
void dynamicArray(){
    int *pia = new int[10]; // 数组的原始没有初始化
    string *psa = new string[10]; //10个空字符串
    int *pia = new int[10];       // 10个未初始化的int元素
    int *pia2 = new int[10] (); //元素都为0 
}
```

使用示例：
```
#include <iostream>
using namespace std;
int main(void){
    int i, n;
    cout << "Nums to be input: " << endl;
    cin >> n; 
    int *p = new int[n];
    cout << "Input nums: " << endl;
    for (i = 0; i < n; i++)
        cin >> p[i];
    cout << "Nums you input: " << endl;
    for (i = 0; i < n; i++)
        cout << p[i] << " ";
}
```

### 空数组

C++ 虽然不允许定义长度为 0 的数组变量，但明确指出，调用 new 动态创建长度为 0 的数组是合法的：

```
char arr[0];            //错误
char *cp = new char[0]; // 允许
```

### 释放动态数组

动态分配的内存最后必须进行释放，否则，内存最终将会逐渐耗尽。如果不再需要使用动态创建的数组，
程序员必须显式地将其占用的存储空间返还给程序的自由存储区。C++ 语言为指针提供 delete [] 表达式释放指针所指向的数组空间：
```
delete [] pia;//切记不要忘记[]符号
```

### const 对象的动态数组

如果我们在自由存储区中创建的数组存储了内置类型的 const 对象，则必须为这个数组提供初始化，
因为数组元素都是 const 对象，无法赋值。实现这个要求的唯一方法是对数组做值初始化：

```
// 错误，必须提供初始化值
const int *pci_bad = new const int[100]; 
//正确
const int *pci_ok = new const int[100]();
```
C++ 允许定义类类型的 const 数组，**但该类类型必须提供默认构造函数**：
```
const string *pcs = new const string[100];
```