# 迭代器

迭代器是一种机制，用于迭代容器(比如string或vector)中的元素。类似于指针类型，迭代器也提供了对对象的间接访问。

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员，这些类型都有begin和end成员。
end指向一个不存在的尾后，成为尾后迭代器(尾迭代器)，如果容器的为空，则begin和end同时指向尾迭代器。


## 1 泛型编程

c++程序员习惯性的使用`!=`，其原因与他们更愿意使用迭代器而非下标的原因一样。这种编程风格在标准库提供的所有容器上都有效。
所有标准库容器的迭代器都定义了`!=和=`，但它们中大多没有`<`运算符。因此只要养成此种(使用迭代器和`!=`)编程习惯，就不同
太在意使用的是哪种类型的迭代器。

## 2 迭代器类型

不需要知道iterator到底是什么类型，标准库使用`iterator和const_iterator`表示迭代器类型

```
vector<int>::iterator it;//it能读写vector中的元素
string::iterator it;//it能读写string中的元素
vector<int>::const_iterator it;//it只能读取vector中的元素
string::const_iterator it;//it只能读取string中的元素
```

迭代器这个名词有三个概念：

- 迭代器概念本身
- 容器定义的迭代器类型
- 指某个具体的迭代器对象

而重点在于理解一组概念上相关的类型，我们认为某个类型是迭代器，当且仅的它支持一套操作，这套操作使得我们可以访问容器的元素或者从某个元素移动到另一个元素。
每个容器类定义的iterator都支持这么一套操作。

begin和end返回的类型与对象是否为常量决定，如果对象是常量，则begin和end返回const_iterator类型，如果不是const的则返回iterator类型。

## 3 迭代器运算

iter表示迭代器

- `*iter`：返回迭代器所指向元素的引用
- `iter->men`：解引用iter，等价于(*iter).mem
- `++iter`：指向下一个元素
- `--iter`：指向上一个元素
- `iter1 == iter2`：如果两个迭代器指示的是同一个元素，或它们是同一个容器的尾迭代器则相等。
- `iter1 != iter2`
- `iter +n`：向后移动n个位置
- `iter +=n`：迭代器加法符合语句，将iter+n的结果赋值给inter
- `>、<、<=、>=`：位置比较

注意：但凡使用了迭代器循环体，就不要向迭代器所属容器添加元素了。

## 4 ->操作符

`->`操作符把解引用和成员操作符结合在一起