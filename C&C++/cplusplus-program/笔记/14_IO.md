# IO库

C++不直接处理输入输出，而是通过定义在标准库中的类型来处理IO。

## 1 IO类

为了支持不同的IO操作，标准库定义了一些IO类型，分别在3个独立的头文件中。

**头文件：iostream**
    - istream、wiostream 从流读取数据
    - ostream、wostream 从流写入数据
    - iostream、wiostream 读写流

前面用到的cin是istream是实现，而cout是ostream的实现。

**头文件：fstream**
    - ifstream、 wifstream 从文件读取数据
    - ofstream、 wofstream 向文件写入数据
    - fstream、wfstream 读写文件
   
**头文件：sstream**
    - istringstream、wistringstream 从string读取数据
    - ostringstream、wostringstream 向string写入数据
    - stringstream、wstringstream 读写string
    
以w开头的IO类型，用处理宽字符。


### IO类型之间的关系

通过**继承机制**，C++屏蔽了具体IO操作的细节，标准库是我们能够忽略不同类型的流之间的差异。

类型`ifstream`、`istringstream`都继承自`istream`类。

###  IO对象无拷贝和赋值

IO对象不能够被拷贝和赋值，这个要求有两层特别重要的含义：

- 只有支持复制的元素类型可以存储在 vector 或其他容器类型里。由于流对象不能复制，因此不能存储在 vector（或其他）容器中（即不存在存储流对象的 vector 或其他容器）。
- 不能将形参和返回类型设置为IO类型，通常以引用的方式传递和返回流，读写一个IO对象会改变其状态，因此传递和返回的流的引用不能使const的。

### IO条件状态

IO操作与生俱来的问题就是可能发生错误，一些错误可以修复，一些系统深处的错误却超出了应用程序的处理范围，下面列出的一些函数和标识可以帮助我们
访问和操纵流的条件状态:

 
状态	| 含义
--- | ---
`strm::iostate`		| strm是一种IO类型。iostate是一种机器相关的整型，提供了表达条件状态的完整功能
`strm::badbit`		| strm::badbit用来指出流已崩溃
`strm::failbit`		| strm::failbit用来指出一个IO操作失败了
`strm::eofbit	`	| strm::eofbit用来指出流达到了文件结束
`strm::goodbit`		| strm::goodbit用来指出流未处于错误状态。此值保证为零
`s.eof()	`	| 若流 s 的 eofbit 置位，则返回 true
`s.fail()	`	| 若流 s 的 failbit 或 badbit 置位，则返回 true
`s.bad()	`	| 若流 s 的 badbit 置位，则返回 true
`s.good()`		| 若流 s 处于有效状态，则返回 true
`s.clear()`		| 将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void
`s.clear(flag)	`	| 根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是`strm::iostate`。返回 void，flag示例：`cin.rdstate() & ~cin.failbit & ~cin.badbit`表示复位failbit和badbit，其他位保持不变
`s.setstate(flag)`		| 根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是`strm::iostate`。返回 void
`s.rdstate()`		| 返回流 s 的当前条件，返回值类型为 `strm::iostate`


参考下面代码：

```
int val
cin >> val
```
如果在标准输入流中输入字符串"BOO"，读操纵会失败，cin会进入错误状态，类似如果输入一个文件
结束标识，cin也会进入错误状态。**一旦一个流发生错误，其后续的操纵都会失败**，由于在操作
流时，流可能处于错误状态，所以代码应该在使用流之前检查流是否处于正常状态。比如：
```
while(cin >> word){
    //ok 操作时成功的
}
```

有时需要知道流发生了什么错误，IO定义的`iostate`是一种机器相关的整型，提供了表达条件状态的完整功能，
这个类型应该作为一个位集来使用，IO库定义了4个`iostate`类型的constexpr值标识特定的位模式。


四种条件状态：

状态	 | 含义	 | 数值	 | good()	 | eof()	 | bad()	 | fail()	 | rdstate()
---|---|---|---|---|---|---|---
`ios::goodbit`	 | 流状态完全正常	 | 0	 | 1	 | 0	 | 0	 | 0	 | goodbit
`ios::eofbit` | 	已达到文件结束	 | 2	 | 0	 | 1	 | 0	 | 0	 | eofbit
`ios::badbit`	 | 输入（输出）流出现非致命错误，可挽回	 | 1	 | 0	 | 0	 | 1	 | 0	 | badbit
`ios::failbit`	 | 输入（输出）流出现致命错误，不可挽回	 | 4	 | 0	 | 0	 | 0	 | 1	 | failbit

`goodbit`为0表示流未发生错误，如果badbit、failbit、 eofbit任一个被置位，则检查流状态的条件都会失败。
**使用`good和fail`是确定流整体状态的正确方法，我们将流当作条件使用的代码就等价于`!fail()`,而eof和badbit只表示特定类型的错误。**


### 管理输出缓冲

每个操作系统都管理着一个缓冲区，用来保存程序读写的数据，因为设备的读写操作很耗时，所以操作系统运行将多个输入输出操作组合为一个设备的读写操作。下面代码可以理解执行，也可能被操作系统保留在缓冲区，随后再输出。
```
std::cout << "abcdefg"
```

导致缓冲区刷新的原因有很多，例如：
- 程序正常退出
- 使用操作符号`endl`显示刷新
- 在每个输出操作后，使用操作符`unitbuf`设置流的内部状态来情况缓冲区
- 一个输出流可能被关联到另一个，当读写被关联时，关联到的流的缓冲区将被刷新

注意：**当程序崩溃，缓冲区不会刷新。**

#### 缓冲区刷新
```
cout << "hi" << endl; // 换行+刷新缓冲区
cout << "hi" << flush; // 刷新缓冲区不附加任何字符
cout << "hi" << ends; //  附加一个空字符，然后刷新缓冲区
```
#### unitbuf

`unitbuf`告诉流接下来的每一次操作都要刷新一次，`nounitbuf`重置
```
cout << unitbuf;//每一次操作都要刷新一次
        ......流操作
cout << nounitbuf;//复位
```
#### 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会刷新关联的输出流。标准库将cout和cin关联在一起。
```
int a;
cin >> a; //输入的同事cout也会输出
```

关联函数位`tie()`，tie由两个版本：
- 无参的tie：返回指向输出流的指针，如果本对象当前关联到一个输出流，返回指向该输出流的指针，否则返回空指针
- 接受一个指向ostream的指针，将自己关联到指针指向的ostream，`x.tie(&o)`表示将x关联到o

可以将一个istream关联到ostream，可以将一个ostream关联到istream：
```
cin.tie(&out);
//old_tie指向当前流关联到cin的流
ostream *old_tie = cin.tie(nullptr);// cin不再与其他流关联
//将cin与cerr关联，开发中不要这么做
cin.tie(&cerr);
cin.tie(old_tie);
```
每个流最多同时关联到一个流，但多个流可以同时关联到同一个`ostream`。


---
## 2 文件操作


---
## 3 string流


