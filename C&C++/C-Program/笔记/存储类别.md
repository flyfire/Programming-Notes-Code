# 存储类别

---
##  1 作用域

一个C变量的作用域可以是：**块级作用域、函数作用域(仅用于goto语句)、函数原形作用域。**

```
int unists = 0;//unists具有文件作用域，更准确的说，它具有外部连接文件作用域
int main(){

}  
```

###  翻译单元和文件

你认为的多个文件在编译器中可以以单个文件出现，例如在源代码中包含一个或者多个头文件，头文件会一次包含其他头文件，所以会包含
多个独立的物理文件，但是C预处理实际上是用包含的头文件替换#include指令，所以编译器源代码文件和所有的头文件都看成是一个包含
信息的单独文件，这个文件被称为翻译单元(translation unit)。描述一个具有文件作用域的变量时，它实际的可见范围是整个翻译单元，如果程序
由多个源代码文件组成，那么该程序也将由多个翻译单元组成，每个翻译单元均对应一个源代码文件和它对应的多个包换的文件。

--- 
## 2 连接

C变量具有三种连接属性：**外部链接、内部链接、无链接。**

无链接对应的变量作用域：函数作用域、块级作用域、函数原形作用域

具有文件作用域的变量可以是外部链接或者内部链接

- 内部链接：只能在一个翻译单元中使用
- 外部链接：可以在多文件程序中使用

```
int giants = 5;//文件作用域，外部链接，称为内部链接文件作用域，简称文件作用域
static int dodgers = 4;//文件作用域，内部链接，称为外部链接文件作用域，简称全局作用域或程序作用域
int main(){}
```

**对于文件作用域变量，关键字static表明的是链接属性，而不是存储期**

### 存储期

C对于具有四种存储期：

- 静态存储期：外部链接和内部链接都是静态存储期
- 线程存储期：用于并发设计
- 自动存储期：auto
- 动态分配存储期：使用malloc()申请内存

存储类别|存储期|作用域|链接|声明方式
---|---|---|---|---|
自动|自动|块|无|块内
寄存器|自动|块|无|块内，register修饰
静态外部链接|静态|文件|外部|所有函数外
静态内部链接|静态|块|内部|所有函数外，使用static修饰
静态无链接|静态|块|无|块内，使用static修饰

**定义和声明**：extern用于声明需要用到定义在别处的变量，而不是用来定义变量，不要用extern来定义变量。


### 多文件

只有当程序有多个翻译单元组成时，才体现区别内部变量和外部变量的重要性。复杂的C程序通常由多个翻译单元组成，
有时这些文件需要共享一个外部变量，C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。

### 存储类别说明符

关键字static和extern的含义取决于上下文，C语言有6个关键字作为存储类别声明符：auto、register、extern、static、_Thread_local和typedof(语法原因归于此处)。
大多数情况下不能同时使用多个存储类别说明符，唯一列外的是_Thread_local，它可以和static和extern一起使用。

- auto说明变量式自动存储期
- register说明符只能用于块作用域的变量，保护了该变量的内存地址不会被获取
- static说明符创建的对象具有静态存储期
- extern说明符表明声明的变量定义在别处。


---
## 3 存储类别和函数

函数也有存储类别：

- 外部函数(默认)
- 静态函数
- 内联函数(C99)

```
double gamma(double);//该函数为外部函数
static doble beta(int,int);//该函数为静态函数
extern double delte(double,int);//用extern来声明定义在其他文件的函数
```

### 存储类别选择

存储类别选择：优先使用自动存储类别。不要轻易定义共享变量，以防止该变量被篡改，唯一例外的是const数据。因为它们在初始化以后不会被修改。

**定义变量的法则：**按需知道，尽量在函数内部解决所有任务，只共享那些需要共享的变量


---
##  ANSI C类型限定符

通常用类型和存储类别来描述一个变量。

C90新增了两个属性：
- 恒常性，对应const关键字
- 易变性，对应volatile关键字

C99新增了第三个限定符：restrict用于提高编译器优化
C11新增了第四个限定符：_Atomic

### const

### volatile

### restrict

### Atomic