# c提高

建立正确的程序运行内存布局图是学好C语言的关键。

##  1 程序内存模型

###  数组当作参数时会退化为指针
```
static void passArray(int intArr[]) {
    int size = sizeof(intArr);//8
    printf("stack size = %d \n", size);
}


static void array() {
    int intArr[10];
    int size = sizeof(intArr);//40
    printf("stack size = %d \n", size);
    passArray(intArr);
}
```



###  数据类型的本质

数据类型可以理解位创建遍历的一个模具，是固定内存块大小的别名，通过sizeof测试。
其作用是让编译器预算对象分配内存空间的大小。

变量是既能读又能写的内存对象，其本质是一段连续内存空间的别名。
程序通过变量来申请和命名内存空间` int a = 0`，变量三要素(名称、大小、作用域)。

指针也是一种数据类型。指针变量也是一种变量，指针指向谁就把谁的地址赋值给指针。

```
int a = 10;     //4个字节
int b[10];      //4*10个字节，&b表示取整个数组的首地址，也就是40个字节
printf("%p, %p, %p, %p ", &a, &a+1, &b, &b+1);//&a+1加了4，&b+1加了40
```

### sizeof

`sizeof`是操作符，不是函数；`sizeof`测量的实体大小为编译期间就已确定

### void类型

- 当函数的无参数时，int fun(void);
- 当函数无返回值时，void fun(int a);
- 不能定义void类型变量，因为void表示没有类型，所以无法确定内存的大小
- 可以定义void *类型，指针类型的大小是固定的
- void *是万能指针，函数参数，返回值等等
- void *用作数据类型封装，典型的如内存操作函数malloc：`void *__cdecl malloc(size_t _Size);`
- void *在使用时应该转换为实际类型的指针

### pragma once

```
#progam once //可用于头文件中，防止头文件重复包含
```

### 内存四区

- 堆区
- 栈区
- 全局区、文字常量区
- 代码区

![](images/memory_area.png)

**如何分析程序内存分配——绘制内存四区图**



### 函数的调用模型 

- 函数的模型是一个栈的模型，先进后出
- 关心函数调用顺序，函数内部变量的作用域，不关心出栈进栈
- 函数结束后，变量是否还存在内存中
- main在占空间分配的内存，在起后面的其他子函数都可以使用


### 内存的生长方向

- 栈的生长方向是高位到地位
- 堆的生长方向是低位到高位
- 注意：栈中声明的一个数组buf，`buf+1`顺序永远是由低位到高位分配


---
## 2 指针知识体系搭建





---
## 引用

- [博学谷](http://yun.itheima.com/)