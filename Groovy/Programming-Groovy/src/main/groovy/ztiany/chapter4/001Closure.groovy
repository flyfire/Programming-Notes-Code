package ztiany.chapter4

/*
闭包是轻量级的、短小的、简洁的、而且将会是我们在Groovy中使用最多的特性之一，过去我们需要传递匿名内部类，现在我们可以传递闭包。

闭包是从函数式(一种编程规范，主要思想是把一些列运算写成一系列嵌套的函数调用)的Lambda表达式派生而来的，一个Lambda表达式指定了
一个函数的参数与映射)派生而来的
 */

//--------------------
//闭包的便利性
//--------------------
//实例1：求一到某一个特定值n之间的所有偶数之和

//传统方式
def sum(int n) {
    total = 0;
    for (int i = 2; i <= n; i += 2) {
        total += i
    }
    total
}

println sum(10)

//现在需求变了，要求一个数到某一个特定值n之间的所有偶数之积，以是代码变成了这样的
def product(int n) {
    total = 1;
    for (int i = 2; i <= n; i += 2) {
        total *= i
    }
    total
}

println product(10)
//后面每次的需求变化，都需要更改代码

//Groovy的方式，上面计算方式都有一个共同点，从1到给定的数之间挑选出偶数，我们可以抽出这段代码：
def pickEven(int n, closure) {
    for (int i = 2; i <= n; i += 2) {
        closure(i)
    }
}

pickEven(10, {
    println it
})

/*
pickEven是一个高阶函数(以函数为参数，或者返回一个函数作为结果的函数)，与前面方式一样pickEven对给定的值进行迭代，但不同的是
pickEven把值发送给一个代码块，在groovy中我们称这种代码块为闭包(Closure),上面变量closure指向的是一个闭包的引用，可以像传递对象一样传递闭包，

pickEven(10, {
    println it
})表示将代码块{println it}传递给closure，就像把10传递给n一样，如果一个方法的最后一个参数是闭包，我们可以简写成一下方式：

pickEven 10,{
    println(it)
}
或者：
pickEven (10){//当方法的最后一个参数是闭包，可以让闭包附到方法的调用上
    println(it)
}

，不同于Java的代码块，groovy的闭包不能单独存在，只能附到一个方法上或者赋值给一个变量
 */

//如果代码块只有一个参数，则可以使用it来引用这个参数，就像上面一样。与下面代码的意思是一样的
pickEven 10 , {
    n ->
        println n
}

//了解完闭包，我们来使用闭包实现上面的求值
sum1 = 0
pickEven(10){
    sum1 += it
}
product1 = 1;
pickEven(10){
    product1 *= it
}
println "sum1 = $sum1"
println "product1 = $product1"
//处理语法上的优雅，闭包还函数将部分实现逻辑委托出去提供了一种简单的，方便的方式



/*
上面演示的代码块中，闭包使用了product1，可见闭包将触角伸到了pickEvent的调用者的作用域内，这是闭包的一个有趣的特性，闭包是一个函数，
这里变量都绑定到一个上下文环境中，这个函数就在其中，
 */

//--------------------
//闭包的应用
//--------------------
/*
比好有两个擅长的领域：
1. 赋值清理资源
2. 赋值创建领域特定语言，
普通函数在实现某个目标明确的功能时优于闭包，重构是引入闭包的好时机
，闭包应该保持短小，有内聚性，应该把闭包设计为附到调用方法上的上的一小段代码，最好不要乱用闭包的动态属性，比如在运行时
确定参数的数目和类型
 */




















