# 第十八章：单元测试与模拟


## 1 单元测试

单元测试对于编程至关重要，不管静态类型语言的编译器执行类型检查多么弱，动态类型语言甚至连这种程度都没有支持，这就是动态语言中单元测试存在的必要原因了。

###  本书作者单元测试体会

- 促进了我对groovy特性的理解
- 在groovy用户邮件列表中提出的问题帮助修复了一些groovy的bug
- 帮助找到并修复了groovy文档中的一处不一致
- 帮我确保所有示例都是有效的，而且在最新版的groovy中可以很好的工作
- 让我有勇气随意的、随时的重构任何示例，而且让我可以充满自信的说：我对重构会改进代码的结构，但是不会影响预期的行为



###   对Java和Groovy代码执行单元测试

由于Java-Groovy集成，任何基于Java的测试框架和模拟对象的框架(EasyMock、JMock、Mockito)都可以结果Groovy使用

而且在安装Groovy时就集成了JUnit单元测试框架，只需要扩展GroovyTestCase类即可实现测试



### 单元测试必须满足FAIR条件

在编写单元测试时，必须满足FAIR条件：**快速(Fast)、自动化(Automated)、隔离(isolated)、可重复(repeatable).**

- 测试必须要快，随着代码的演进和重构，需要快速得到代码仍然能够满足预期的反馈，如果很慢相比没有开发者会愿意运行它们
- 测试必须是自动化的，手工测试很累，而且容易出错，而相当于减少了投入在重要任务上的时间
- 测试必须隔离，比如碰到1031编译器错误，通常问题就是少了个分号，是吧？这没有实质的帮助，一个小错误级联到一对错误的报告是毫无意义的，我们想要的是因此的bug或错误与失败的测试用例之间的直接关联。
- 测试必须是可重复的，测试一定要能够运行N次，并且得到确定性、可预期的测试结果。如果这次运行失败未作任何修改、下次运行又成功了，这从测试是最坏的。

### 在编写单元测试时，应该考虑3种测试：正面测试、负面测试、异常测试。

- 正面测试可以帮助我们确定代码的表现符合预期，可以在正常的路径上调用这种测试，比如一个账户种存入100美元，然后检查余额是不是这么多了
- 负面测试检查的是，代码能否按照预期的方式处理前置条件无效、无效输入等问题。存入一个负值，看看代码或做什么，如果用户账户关闭，又会做什么
- 异常测试可以帮主确定的是，当异常情况出现时，代码是否会抛出正确的异常，以及表示是否符合预期。如果账户关闭，自动取款操作发起会怎么样？

以这些属于来思考，又助于我们把实现逻辑彻底想清楚，我们不仅要处理实现逻辑的代码，还要考虑常常会让我们陷入困境的**边界条件和极端条件**


        
        
        