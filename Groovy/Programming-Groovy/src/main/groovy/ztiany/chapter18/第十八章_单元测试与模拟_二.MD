# 第十八章：单元测试与模拟

## 2 模拟测试

对存在大量依赖的代码进行单元测试，就算并非没有可能，也是非常困难的。
单元测试有一个优点，它会强制我们让代码单元小一些，代码越小，其内聚就越高。它还会强制我们预期周边的环境解耦。
        
耦合的两种形式：有的代码会依赖我们的代码，有的代码是我们所依赖的。在对我们的代码进行单元测试时，需要解决这两种耦合。

必须将被测试代码从其所在的应用中分离或者解耦出来，比如位于GUI中的逻辑很难进行单元测试，比如逻辑依赖某个响应很慢的、代码高昂的、不可预测的、或者正处于
开发阶段，也无法进行单元测试。

将被测试代码从其所在的应用中分离可以借助存根和模拟来实现。

- 存根：存根用于代替真正的对象，当被测方法调用存根时，它会根据设定好的预期响应简单的应答，之所以要应答是为了满足测试通过的需要。
- 模拟对象：模拟对象所在的事比存根要多得多，它可以帮助确定被测代码按预期方式与依赖或协作对象交互，模拟对象可以记录代码中在该对象的协作对象上进行方法调用的次序和次数。
它可以确保传给方法调用的是正确的参数。

存根验证状态，模拟验证行为，当在测试中使用模拟时，它不仅验证状态，也验证了代码与其依赖的交互行为。


我们所以来的代码被称为协作者，我们的代码与协作者合作完成工作，协作者可以是一个组件、对象、层次、子系统。其可能是局部的或者远程的，没有协作者我们的对象无法行使其功能，然而为了满足测试需求，需要替换掉协作者。

模拟用于替换调协作者，其不做任何真正的工作， 而只是简单的像调用它的代码做出预期的响应，以便让测试进行工作。


在Java中可以使用**接口**实现，java框架(EasyMock、JMock、Mockito)简化了模拟，其中一些甚至不需要创建接口就能实现模式(基于代理机制)。
Groovy的动态特性和元编程能力在这方面又很大的优势，Groovy创建模拟又如下范式：

- 方法覆盖
- 分类
 - ExpandoMateClass
 - Expando
 - Map
 - Groovy的Mock Library
 
 
 
 
 方法覆盖,分类, ExpandoMateClass,以测试`CodeWithHeavierDependencies.groovy`为例,
 Expando,Map, Groovy的Mock Library,以测试`ClassWithDependency.groovy`为例,
 
 
 
 
 >其他测试框架：gmock，Spock
 

