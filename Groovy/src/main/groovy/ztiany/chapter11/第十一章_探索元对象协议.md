# 第十一章：探索元对象协议

Groovy的元编程提供了在运行时修改对象的类型或者让其动态的获得行为的能力，不再局限于java的静态结构，我们可以基于应用所接受的
输入，动态的添加方法和行为。

**所谓元编程(metaPrograming)就是**：能够编程操作程序的程序，包括操作程序自身

Groovy这样的动态语言通过元对象协议(MetaObject Protocol)提供这种能力，Groovy的元编程核心是MetaClass。

## 1 Groovy对象

Groovy对象是带有附加功能的Java对象。

Groovy应用中对象分为三类：

- POJO 使用Java或其他JVM语言编写的创建的
- POGO 用Groovy编写的对象
- Groovy拦截器(实现了GroovyInterceptable)的Groovy对象


所有的Groovy类就扩展了GroovyObject接口
    
        public interface GroovyObject {
                Object invokeMethod(String name, Object args);
                Object getProperty(String propertyName);
                void setProperty(String propertyName, Object newValue);
                MetaClass getMetaClass();
                void setMetaClass(MetaClass metaClass);
        }
    
            invokeMethod/getProperty/setProperty 使Java对象有了高度的动态性
            getMetaClass/setMetaClass 使创建代理拦截POGO上的方法调用，在POGO上注入方法变得容易
            
            
GroovyInterceptable继承了GroovyObject，是一个标记类型的接口，对于实现了该接口的方法，其上所有的方法调用(不管方法是否存在)都会
被invokMethod方法拦截
            
            
Groovy支持对POJO和POGO进行元编程：

- 对应POJO，Groovy维护了MetaClass的一个MetaClassRegistry。
- 对于POGO，都有一个到其MetaClass的直接引用，当调用一个方法时，Groovy会检查目标对象是POJO还是POGO

>Class对象上的metaClass时该对象及其子类公共的，但是如果某个Class的实例拥有方法的实现时，优先调用实例上MetaClass的方法。

对于不同对象的类型，Groovy处理方法并不一样：

- POJO：Groovy会去应用类的MetaClassRegistry（注册表）取它的metaClass，并将方法委托给它，因此
在他的metaClass上定义的任何拦截器或者方法，都要优先于POJO原来的方法。
- POGO：如果对象没有实现GroovyIntercepable：
    -  1     先查找他的metaClass中的方法，有则调用
    -  2    没有则查找自身的方法，有则调用
    -  3    没有则以方法名查找属性字段，如果属性字段是Closure，Groovy会调用它
    -  4    没有则查看自身是有一个methodMissing的方法，有则调用，没有就会调用POGO的invokeMethod(),如果POGO
                实现invokeMethod()方法则调用，默认invokeMethod(),抛出MissingMethodException
- 如果对象实现了GroovyIntercepable：调用POGO的invokeMethod()方法
            
**由此可见，方法调用时，metaClass的优先级高于对象本身。** ,具体演示可以查看`GroovyMethodInvocation.groovy`



## 2 查询方法和属性
        
        meteClass.getMetaMethod()
    
## 3 动态的访问对象
    
- 动态的访问属性
- 动态的访问方法


具体查看`001GroovyMOP.groovy`


